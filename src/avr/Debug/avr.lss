
avr.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000100  00800100  00001d7a  00001e0e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001d7a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000005d  00800200  00800200  00001f0e  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00001f0e  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000002f8  00000000  00000000  00001f6a  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00002e33  00000000  00000000  00002262  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000d62  00000000  00000000  00005095  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000e96  00000000  00000000  00005df7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000854  00000000  00000000  00006c90  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000008d9  00000000  00000000  000074e4  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00002083  00000000  00000000  00007dbd  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000002c0  00000000  00000000  00009e40  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__ctors_end>
       4:	0c 94 e4 02 	jmp	0x5c8	; 0x5c8 <__vector_1>
       8:	0c 94 2b 01 	jmp	0x256	; 0x256 <__vector_2>
       c:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      10:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      14:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      18:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      1c:	0c 94 19 01 	jmp	0x232	; 0x232 <__vector_7>
      20:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      24:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      28:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      2c:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      30:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      34:	0c 94 ea 09 	jmp	0x13d4	; 0x13d4 <__vector_13>
      38:	0c 94 9c 02 	jmp	0x538	; 0x538 <__vector_14>
      3c:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      40:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      44:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      48:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      4c:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      50:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      54:	0c 94 96 00 	jmp	0x12c	; 0x12c <__vector_21>
      58:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      5c:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      60:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      64:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      68:	ff 04       	cpc	r15, r15
      6a:	08 05       	cpc	r16, r8
      6c:	11 05       	cpc	r17, r1
      6e:	1a 05       	cpc	r17, r10
      70:	23 05       	cpc	r18, r3
      72:	2c 05       	cpc	r18, r12
      74:	35 05       	cpc	r19, r5
      76:	3e 05       	cpc	r19, r14
      78:	47 05       	cpc	r20, r7
      7a:	50 05       	cpc	r21, r0
      7c:	c4 05       	cpc	r28, r4
      7e:	c4 05       	cpc	r28, r4
      80:	c4 05       	cpc	r28, r4
      82:	c4 05       	cpc	r28, r4
      84:	c4 05       	cpc	r28, r4
      86:	c4 05       	cpc	r28, r4
      88:	c4 05       	cpc	r28, r4
      8a:	59 05       	cpc	r21, r9
      8c:	62 05       	cpc	r22, r2
      8e:	6b 05       	cpc	r22, r11
      90:	74 05       	cpc	r23, r4
      92:	7d 05       	cpc	r23, r13
      94:	86 05       	cpc	r24, r6
      96:	c4 05       	cpc	r28, r4
      98:	c4 05       	cpc	r28, r4
      9a:	c4 05       	cpc	r28, r4
      9c:	c4 05       	cpc	r28, r4
      9e:	c4 05       	cpc	r28, r4
      a0:	c4 05       	cpc	r28, r4
      a2:	c4 05       	cpc	r28, r4
      a4:	c4 05       	cpc	r28, r4
      a6:	c4 05       	cpc	r28, r4
      a8:	c4 05       	cpc	r28, r4
      aa:	c4 05       	cpc	r28, r4
      ac:	c4 05       	cpc	r28, r4
      ae:	c4 05       	cpc	r28, r4
      b0:	c4 05       	cpc	r28, r4
      b2:	c4 05       	cpc	r28, r4
      b4:	c4 05       	cpc	r28, r4
      b6:	c4 05       	cpc	r28, r4
      b8:	c4 05       	cpc	r28, r4
      ba:	c4 05       	cpc	r28, r4
      bc:	c4 05       	cpc	r28, r4
      be:	c4 05       	cpc	r28, r4
      c0:	c4 05       	cpc	r28, r4
      c2:	c4 05       	cpc	r28, r4
      c4:	c4 05       	cpc	r28, r4
      c6:	c4 05       	cpc	r28, r4
      c8:	c4 05       	cpc	r28, r4
      ca:	8f 05       	cpc	r24, r15
      cc:	98 05       	cpc	r25, r8
      ce:	a1 05       	cpc	r26, r1
      d0:	aa 05       	cpc	r26, r10
      d2:	b3 05       	cpc	r27, r3
      d4:	bc 05       	cpc	r27, r12

000000d6 <__ctors_end>:
      d6:	11 24       	eor	r1, r1
      d8:	1f be       	out	0x3f, r1	; 63
      da:	cf ef       	ldi	r28, 0xFF	; 255
      dc:	d8 e0       	ldi	r29, 0x08	; 8
      de:	de bf       	out	0x3e, r29	; 62
      e0:	cd bf       	out	0x3d, r28	; 61

000000e2 <__do_copy_data>:
      e2:	12 e0       	ldi	r17, 0x02	; 2
      e4:	a0 e0       	ldi	r26, 0x00	; 0
      e6:	b1 e0       	ldi	r27, 0x01	; 1
      e8:	ea e7       	ldi	r30, 0x7A	; 122
      ea:	fd e1       	ldi	r31, 0x1D	; 29
      ec:	02 c0       	rjmp	.+4      	; 0xf2 <__do_copy_data+0x10>
      ee:	05 90       	lpm	r0, Z+
      f0:	0d 92       	st	X+, r0
      f2:	a0 30       	cpi	r26, 0x00	; 0
      f4:	b1 07       	cpc	r27, r17
      f6:	d9 f7       	brne	.-10     	; 0xee <__do_copy_data+0xc>

000000f8 <__do_clear_bss>:
      f8:	22 e0       	ldi	r18, 0x02	; 2
      fa:	a0 e0       	ldi	r26, 0x00	; 0
      fc:	b2 e0       	ldi	r27, 0x02	; 2
      fe:	01 c0       	rjmp	.+2      	; 0x102 <.do_clear_bss_start>

00000100 <.do_clear_bss_loop>:
     100:	1d 92       	st	X+, r1

00000102 <.do_clear_bss_start>:
     102:	ad 35       	cpi	r26, 0x5D	; 93
     104:	b2 07       	cpc	r27, r18
     106:	e1 f7       	brne	.-8      	; 0x100 <.do_clear_bss_loop>
     108:	0e 94 0e 0a 	call	0x141c	; 0x141c <main>
     10c:	0c 94 bb 0e 	jmp	0x1d76	; 0x1d76 <_exit>

00000110 <__bad_interrupt>:
     110:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000114 <ADC_stop>:
void ADC_stop()
{   
	/*
    *ADSC :ADC stops interruption
	*/
	ADCSRA &= ~((1<<ADIE));
     114:	ea e7       	ldi	r30, 0x7A	; 122
     116:	f0 e0       	ldi	r31, 0x00	; 0
     118:	80 81       	ld	r24, Z
     11a:	87 7f       	andi	r24, 0xF7	; 247
     11c:	80 83       	st	Z, r24
     11e:	08 95       	ret

00000120 <ADC_resume>:
void ADC_resume()
{
	/*
    *ADSC :ADC resumes interruption
	*/
	ADCSRA |= (1<<ADIE);
     120:	ea e7       	ldi	r30, 0x7A	; 122
     122:	f0 e0       	ldi	r31, 0x00	; 0
     124:	80 81       	ld	r24, Z
     126:	88 60       	ori	r24, 0x08	; 8
     128:	80 83       	st	Z, r24
     12a:	08 95       	ret

0000012c <__vector_21>:
	//while ( ADCSRA & (1<<ADSC));
	return ADC;
}

ISR(ADC_vect)
{   
     12c:	1f 92       	push	r1
     12e:	0f 92       	push	r0
     130:	0f b6       	in	r0, 0x3f	; 63
     132:	0f 92       	push	r0
     134:	11 24       	eor	r1, r1
     136:	2f 93       	push	r18
     138:	3f 93       	push	r19
     13a:	4f 93       	push	r20
     13c:	5f 93       	push	r21
     13e:	6f 93       	push	r22
     140:	7f 93       	push	r23
     142:	8f 93       	push	r24
     144:	9f 93       	push	r25
     146:	af 93       	push	r26
     148:	bf 93       	push	r27
     14a:	ef 93       	push	r30
     14c:	ff 93       	push	r31
	//unsigned int iCurrertValue = ADC;
	ADC_stop();
     14e:	0e 94 8a 00 	call	0x114	; 0x114 <ADC_stop>
	/*
	* your code
	*/
	ADC_resume();
     152:	0e 94 90 00 	call	0x120	; 0x120 <ADC_resume>
	/*
	*Start new session
	*/
}
     156:	ff 91       	pop	r31
     158:	ef 91       	pop	r30
     15a:	bf 91       	pop	r27
     15c:	af 91       	pop	r26
     15e:	9f 91       	pop	r25
     160:	8f 91       	pop	r24
     162:	7f 91       	pop	r23
     164:	6f 91       	pop	r22
     166:	5f 91       	pop	r21
     168:	4f 91       	pop	r20
     16a:	3f 91       	pop	r19
     16c:	2f 91       	pop	r18
     16e:	0f 90       	pop	r0
     170:	0f be       	out	0x3f, r0	; 63
     172:	0f 90       	pop	r0
     174:	1f 90       	pop	r1
     176:	18 95       	reti

00000178 <Timer0_init>:
/*Delay */
volatile unsigned int  g_sleep_microSeconds;

void Timer0_init()
{
    g_IR_State =IR_START_COMMAND;
     178:	10 92 28 02 	sts	0x0228, r1
    g_IR_Timeout = -1;
     17c:	8f ef       	ldi	r24, 0xFF	; 255
     17e:	80 93 29 02 	sts	0x0229, r24
    g_IR_stop  = 0;
     182:	10 92 27 02 	sts	0x0227, r1
     186:	10 92 26 02 	sts	0x0226, r1
    g_IR_data_4bits = 0;
     18a:	10 92 17 02 	sts	0x0217, r1
    g_IR_possition_hex = 0;
     18e:	10 92 19 02 	sts	0x0219, r1
     192:	10 92 18 02 	sts	0x0218, r1

    TCCR0A |= (1 << WGM01);
     196:	84 b5       	in	r24, 0x24	; 36
     198:	82 60       	ori	r24, 0x02	; 2
     19a:	84 bd       	out	0x24, r24	; 36
    /*
    * Prescaler = 8
    * 8/(16000000) = 0.0000005
    */

    TCCR0B |=(1<<CS01);
     19c:	85 b5       	in	r24, 0x25	; 37
     19e:	82 60       	ori	r24, 0x02	; 2
     1a0:	85 bd       	out	0x25, r24	; 37

    /*Top = OCR0A */
    TCNT0=0x00;
     1a2:	16 bc       	out	0x26, r1	; 38

    /*Set Compare Value*/
    //OCR0A = 200;
    OCR0A = 20;
     1a4:	84 e1       	ldi	r24, 0x14	; 20
     1a6:	87 bd       	out	0x27, r24	; 39

    /*
    *TOIE0 : Timer/Counter0 Overflow Interrupt Enable
    *OCIE0A Timer/Counter0 Output Compare Match A Interrupt Enable
    */
    TIMSK0 |= (1 << OCIE0A)/*|(1 << TOIE0)*/;
     1a8:	ee e6       	ldi	r30, 0x6E	; 110
     1aa:	f0 e0       	ldi	r31, 0x00	; 0
     1ac:	80 81       	ld	r24, Z
     1ae:	82 60       	ori	r24, 0x02	; 2
     1b0:	80 83       	st	Z, r24

    sei();
     1b2:	78 94       	sei
     1b4:	08 95       	ret

000001b6 <INT0_init>:
{
    /*
    * PD2 - Pin D2
    *Any logical change on INT0 generates an interrupt request.
    */
    EICRA  |=(1<<ISC00) ;
     1b6:	e9 e6       	ldi	r30, 0x69	; 105
     1b8:	f0 e0       	ldi	r31, 0x00	; 0
     1ba:	80 81       	ld	r24, Z
     1bc:	81 60       	ori	r24, 0x01	; 1
     1be:	80 83       	st	Z, r24

    /* External Interrupt Request 0 Enable*/
    EIMSK  |=(1<<INT0);
     1c0:	e8 9a       	sbi	0x1d, 0	; 29

    /*Turn on interrupts*/
    sei();
     1c2:	78 94       	sei
     1c4:	08 95       	ret

000001c6 <Timer2_init>:
    /*
    * The OC2A value will not be visible on the port pin unless the data direction for
    * the pin is set to output
    */
    //PORTB |= (1<<PORTB3);
    DDRB  |= (1<<DDB3);
     1c6:	23 9a       	sbi	0x04, 3	; 4
    */

    /*
    *WGM21 : Set to CTC Mode
    */
    TCCR2A |=  (1<<COM2A0)|(1<<WGM21);
     1c8:	e0 eb       	ldi	r30, 0xB0	; 176
     1ca:	f0 e0       	ldi	r31, 0x00	; 0
     1cc:	80 81       	ld	r24, Z
     1ce:	82 64       	ori	r24, 0x42	; 66
     1d0:	80 83       	st	Z, r24
    *
    */
    //TCCR2B =(1<<CS20);

    /*Top = OCR0A */
    TCNT2=0x00;
     1d2:	10 92 b2 00 	sts	0x00B2, r1
    /*
    *Set Compare Value
    * 8/(16000000) = 0.0000005
    * Timer =  0.0000005*26  = 0.000013s
    */
    unsigned  int   iTemp  = 16000000L/(g_ir_formal.carrier_frequency*2);
     1d6:	80 91 01 02 	lds	r24, 0x0201
     1da:	90 91 02 02 	lds	r25, 0x0202
     1de:	a0 91 03 02 	lds	r26, 0x0203
     1e2:	b0 91 04 02 	lds	r27, 0x0204
     1e6:	9c 01       	movw	r18, r24
     1e8:	ad 01       	movw	r20, r26
     1ea:	22 0f       	add	r18, r18
     1ec:	33 1f       	adc	r19, r19
     1ee:	44 1f       	adc	r20, r20
     1f0:	55 1f       	adc	r21, r21
     1f2:	60 e0       	ldi	r22, 0x00	; 0
     1f4:	74 e2       	ldi	r23, 0x24	; 36
     1f6:	84 ef       	ldi	r24, 0xF4	; 244
     1f8:	90 e0       	ldi	r25, 0x00	; 0
     1fa:	0e 94 65 0a 	call	0x14ca	; 0x14ca <__udivmodsi4>
    OCR2A =( unsigned char ) iTemp  -1;
     1fe:	21 50       	subi	r18, 0x01	; 1
     200:	20 93 b3 00 	sts	0x00B3, r18
     204:	08 95       	ret

00000206 <Timer2_CTC_start>:
void Timer2_CTC_start()
{
    /*
    *Prescaler N = 1 and start PWM
    */
    TCCR2B |= (1<<CS20);
     206:	e1 eb       	ldi	r30, 0xB1	; 177
     208:	f0 e0       	ldi	r31, 0x00	; 0
     20a:	80 81       	ld	r24, Z
     20c:	81 60       	ori	r24, 0x01	; 1
     20e:	80 83       	st	Z, r24

    /*wait for registers update*/
    while (ASSR & ((1<<TCN2UB)|(1<<TCR2BUB)));
     210:	e6 eb       	ldi	r30, 0xB6	; 182
     212:	f0 e0       	ldi	r31, 0x00	; 0
     214:	80 81       	ld	r24, Z
     216:	81 71       	andi	r24, 0x11	; 17
     218:	e9 f7       	brne	.-6      	; 0x214 <Timer2_CTC_start+0xe>
}
     21a:	08 95       	ret

0000021c <Timer2_CTC_stop>:

    /*
    * Prescaler N = 1 and Stop PWM
    *
    */
    TCCR2B &= ~((1<<CS20)|(1<<CS21)|(1<<CS22));
     21c:	e1 eb       	ldi	r30, 0xB1	; 177
     21e:	f0 e0       	ldi	r31, 0x00	; 0
     220:	80 81       	ld	r24, Z
     222:	88 7f       	andi	r24, 0xF8	; 248
     224:	80 83       	st	Z, r24

    /*wait for registers update*/
    while (ASSR & ((1<<TCN2UB)|(1<<TCR2BUB)));
     226:	e6 eb       	ldi	r30, 0xB6	; 182
     228:	f0 e0       	ldi	r31, 0x00	; 0
     22a:	80 81       	ld	r24, Z
     22c:	81 71       	andi	r24, 0x11	; 17
     22e:	e9 f7       	brne	.-6      	; 0x22a <Timer2_CTC_stop+0xe>

}
     230:	08 95       	ret

00000232 <__vector_7>:

ISR(TIMER2_COMPA_vect)
{
     232:	1f 92       	push	r1
     234:	0f 92       	push	r0
     236:	0f b6       	in	r0, 0x3f	; 63
     238:	0f 92       	push	r0
     23a:	11 24       	eor	r1, r1
}
     23c:	0f 90       	pop	r0
     23e:	0f be       	out	0x3f, r0	; 63
     240:	0f 90       	pop	r0
     242:	1f 90       	pop	r1
     244:	18 95       	reti

00000246 <INT1_init>:
{
    /*
    * PD3 - Pin D3
    *Any logical change on INT1 generates an interrupt request.
    */
     EICRA  |=(1<<ISC10) ;
     246:	e9 e6       	ldi	r30, 0x69	; 105
     248:	f0 e0       	ldi	r31, 0x00	; 0
     24a:	80 81       	ld	r24, Z
     24c:	84 60       	ori	r24, 0x04	; 4
     24e:	80 83       	st	Z, r24

    /* External Interrupt Request 0 Enable*/
    EIMSK  |=(1<<INT1);
     250:	e9 9a       	sbi	0x1d, 1	; 29

    /*Turn on interrupts*/
    sei();
     252:	78 94       	sei
     254:	08 95       	ret

00000256 <__vector_2>:
}

ISR(INT1_vect)
{
     256:	1f 92       	push	r1
     258:	0f 92       	push	r0
     25a:	0f b6       	in	r0, 0x3f	; 63
     25c:	0f 92       	push	r0
     25e:	11 24       	eor	r1, r1
}
     260:	0f 90       	pop	r0
     262:	0f be       	out	0x3f, r0	; 63
     264:	0f 90       	pop	r0
     266:	1f 90       	pop	r1
     268:	18 95       	reti

0000026a <sleepMicroSeconds>:

void sleepMicroSeconds(unsigned int microseconds)
{
    if (microseconds < 1)
     26a:	00 97       	sbiw	r24, 0x00	; 0
     26c:	59 f0       	breq	.+22     	; 0x284 <sleepMicroSeconds+0x1a>
    {
        return;
    }
	
    g_sleep_microSeconds = 0;
     26e:	10 92 1d 02 	sts	0x021D, r1
     272:	10 92 1c 02 	sts	0x021C, r1
    while (g_sleep_microSeconds <= microseconds);
     276:	20 91 1c 02 	lds	r18, 0x021C
     27a:	30 91 1d 02 	lds	r19, 0x021D
     27e:	82 17       	cp	r24, r18
     280:	93 07       	cpc	r25, r19
     282:	c8 f7       	brcc	.-14     	; 0x276 <sleepMicroSeconds+0xc>
     284:	08 95       	ret

00000286 <Timer2_mark>:

}

void Timer2_mark(unsigned int microseconds)
{
     286:	cf 93       	push	r28
     288:	df 93       	push	r29
     28a:	ec 01       	movw	r28, r24
    Timer2_CTC_start();
     28c:	0e 94 03 01 	call	0x206	; 0x206 <Timer2_CTC_start>
    sleepMicroSeconds(microseconds);
     290:	ce 01       	movw	r24, r28
     292:	0e 94 35 01 	call	0x26a	; 0x26a <sleepMicroSeconds>
}
     296:	df 91       	pop	r29
     298:	cf 91       	pop	r28
     29a:	08 95       	ret

0000029c <Timer2_space>:

void Timer2_space(unsigned int microseconds)
{
     29c:	cf 93       	push	r28
     29e:	df 93       	push	r29
     2a0:	ec 01       	movw	r28, r24
    Timer2_CTC_stop();
     2a2:	0e 94 0e 01 	call	0x21c	; 0x21c <Timer2_CTC_stop>
    sleepMicroSeconds(microseconds);
     2a6:	ce 01       	movw	r24, r28
     2a8:	0e 94 35 01 	call	0x26a	; 0x26a <sleepMicroSeconds>
}
     2ac:	df 91       	pop	r29
     2ae:	cf 91       	pop	r28
     2b0:	08 95       	ret

000002b2 <IR_init>:

void IR_init()
{
    unsigned char readByte = eeprom_read_byte(( uint8_t *) IR_CONFIGURATION_ADD_FIRST_TIME);
     2b2:	82 e1       	ldi	r24, 0x12	; 18
     2b4:	90 e0       	ldi	r25, 0x00	; 0
     2b6:	0e 94 a8 0d 	call	0x1b50	; 0x1b50 <__eerd_byte_m328>
	
    if (readByte != IR_DEFAULT_FIRST_TIME )
     2ba:	81 30       	cpi	r24, 0x01	; 1
     2bc:	b1 f1       	breq	.+108    	; 0x32a <IR_init+0x78>
    {
		/*Store default ->Remote control: BN59-01003A  48khz SAMSUNG TV */
        eeprom_update_word(( uint16_t *) IR_CONFIGURATION_ADD_CARRIER_FREQUENCY, IR_DEFAULT_CARRIER_FREQUENCY);
     2be:	60 e7       	ldi	r22, 0x70	; 112
     2c0:	74 e9       	ldi	r23, 0x94	; 148
     2c2:	80 e0       	ldi	r24, 0x00	; 0
     2c4:	90 e0       	ldi	r25, 0x00	; 0
     2c6:	0e 94 c8 0d 	call	0x1b90	; 0x1b90 <__eeupd_word_m328>
        eeprom_update_word(( uint16_t *) IR_CONFIGURATION_ADD_START_COMMAND, IR_DEFAULT_START_COMMAND);
     2ca:	68 ee       	ldi	r22, 0xE8	; 232
     2cc:	73 e0       	ldi	r23, 0x03	; 3
     2ce:	82 e0       	ldi	r24, 0x02	; 2
     2d0:	90 e0       	ldi	r25, 0x00	; 0
     2d2:	0e 94 c8 0d 	call	0x1b90	; 0x1b90 <__eeupd_word_m328>
        eeprom_update_word(( uint16_t *) IR_CONFIGURATION_ADD_START_MARK, IR_DEFAULT_START_MARK);
     2d6:	6c ec       	ldi	r22, 0xCC	; 204
     2d8:	71 e0       	ldi	r23, 0x01	; 1
     2da:	84 e0       	ldi	r24, 0x04	; 4
     2dc:	90 e0       	ldi	r25, 0x00	; 0
     2de:	0e 94 c8 0d 	call	0x1b90	; 0x1b90 <__eeupd_word_m328>
        eeprom_update_word(( uint16_t *) IR_CONFIGURATION_ADD_START_SPACE, IR_DEFAULT_START_SPACE);
     2e2:	62 eb       	ldi	r22, 0xB2	; 178
     2e4:	71 e0       	ldi	r23, 0x01	; 1
     2e6:	86 e0       	ldi	r24, 0x06	; 6
     2e8:	90 e0       	ldi	r25, 0x00	; 0
     2ea:	0e 94 c8 0d 	call	0x1b90	; 0x1b90 <__eeupd_word_m328>
        eeprom_update_word(( uint16_t *) IR_CONFIGURATION_ADD_BIT_MARK, IR_DEFAULT_BIT_MARK);
     2ee:	63 e4       	ldi	r22, 0x43	; 67
     2f0:	70 e0       	ldi	r23, 0x00	; 0
     2f2:	88 e0       	ldi	r24, 0x08	; 8
     2f4:	90 e0       	ldi	r25, 0x00	; 0
     2f6:	0e 94 c8 0d 	call	0x1b90	; 0x1b90 <__eeupd_word_m328>
        eeprom_update_word(( uint16_t *) IR_CONFIGURATION_ADD_BIT_ONE_SPACE, IR_DEFAULT_BIT_ONE_SPACE);
     2fa:	6b e9       	ldi	r22, 0x9B	; 155
     2fc:	70 e0       	ldi	r23, 0x00	; 0
     2fe:	8a e0       	ldi	r24, 0x0A	; 10
     300:	90 e0       	ldi	r25, 0x00	; 0
     302:	0e 94 c8 0d 	call	0x1b90	; 0x1b90 <__eeupd_word_m328>
        eeprom_update_word(( uint16_t *) IR_CONFIGURATION_ADD_BIT_ZERO_SPACE, IR_DEFAULT_BIT_ZERO_SPACE);
     306:	6b e2       	ldi	r22, 0x2B	; 43
     308:	70 e0       	ldi	r23, 0x00	; 0
     30a:	8c e0       	ldi	r24, 0x0C	; 12
     30c:	90 e0       	ldi	r25, 0x00	; 0
     30e:	0e 94 c8 0d 	call	0x1b90	; 0x1b90 <__eeupd_word_m328>
        eeprom_update_word(( uint16_t *) IR_CONFIGURATION_ADD_LENGTH, IR_DEFAULT_LENGTH);
     312:	60 e2       	ldi	r22, 0x20	; 32
     314:	70 e0       	ldi	r23, 0x00	; 0
     316:	8e e0       	ldi	r24, 0x0E	; 14
     318:	90 e0       	ldi	r25, 0x00	; 0
     31a:	0e 94 c8 0d 	call	0x1b90	; 0x1b90 <__eeupd_word_m328>
        eeprom_update_word(( uint16_t *) IR_CONFIGURATION_ADD_INTERVAL, IR_DEFAULT_INTERVAL);
     31e:	6a e0       	ldi	r22, 0x0A	; 10
     320:	7a e2       	ldi	r23, 0x2A	; 42
     322:	80 e1       	ldi	r24, 0x10	; 16
     324:	90 e0       	ldi	r25, 0x00	; 0
     326:	0e 94 c8 0d 	call	0x1b90	; 0x1b90 <__eeupd_word_m328>
    }
	
    eeprom_update_byte(( uint8_t *) IR_CONFIGURATION_ADD_FIRST_TIME,IR_DEFAULT_FIRST_TIME);
     32a:	61 e0       	ldi	r22, 0x01	; 1
     32c:	82 e1       	ldi	r24, 0x12	; 18
     32e:	90 e0       	ldi	r25, 0x00	; 0
     330:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <__eeupd_byte_m328>
     
	/*Read configuration*/
    g_ir_formal.carrier_frequency   = eeprom_read_word (( uint16_t *) IR_CONFIGURATION_ADD_CARRIER_FREQUENCY);
     334:	80 e0       	ldi	r24, 0x00	; 0
     336:	90 e0       	ldi	r25, 0x00	; 0
     338:	0e 94 b0 0d 	call	0x1b60	; 0x1b60 <__eerd_word_m328>
     33c:	a0 e0       	ldi	r26, 0x00	; 0
     33e:	b0 e0       	ldi	r27, 0x00	; 0
     340:	80 93 01 02 	sts	0x0201, r24
     344:	90 93 02 02 	sts	0x0202, r25
     348:	a0 93 03 02 	sts	0x0203, r26
     34c:	b0 93 04 02 	sts	0x0204, r27
    g_ir_formal.time_start_command  = eeprom_read_word (( uint16_t *) IR_CONFIGURATION_ADD_START_COMMAND);
     350:	82 e0       	ldi	r24, 0x02	; 2
     352:	90 e0       	ldi	r25, 0x00	; 0
     354:	0e 94 b0 0d 	call	0x1b60	; 0x1b60 <__eerd_word_m328>
     358:	90 93 06 02 	sts	0x0206, r25
     35c:	80 93 05 02 	sts	0x0205, r24
    g_ir_formal.time_start_mark     = eeprom_read_word (( uint16_t *) IR_CONFIGURATION_ADD_START_MARK);
     360:	84 e0       	ldi	r24, 0x04	; 4
     362:	90 e0       	ldi	r25, 0x00	; 0
     364:	0e 94 b0 0d 	call	0x1b60	; 0x1b60 <__eerd_word_m328>
     368:	90 93 08 02 	sts	0x0208, r25
     36c:	80 93 07 02 	sts	0x0207, r24
    g_ir_formal.time_start_space    = eeprom_read_word (( uint16_t *) IR_CONFIGURATION_ADD_START_SPACE);
     370:	86 e0       	ldi	r24, 0x06	; 6
     372:	90 e0       	ldi	r25, 0x00	; 0
     374:	0e 94 b0 0d 	call	0x1b60	; 0x1b60 <__eerd_word_m328>
     378:	90 93 0a 02 	sts	0x020A, r25
     37c:	80 93 09 02 	sts	0x0209, r24
    g_ir_formal.time_bit_mark       = eeprom_read_word (( uint16_t *) IR_CONFIGURATION_ADD_BIT_MARK);
     380:	88 e0       	ldi	r24, 0x08	; 8
     382:	90 e0       	ldi	r25, 0x00	; 0
     384:	0e 94 b0 0d 	call	0x1b60	; 0x1b60 <__eerd_word_m328>
     388:	90 93 0c 02 	sts	0x020C, r25
     38c:	80 93 0b 02 	sts	0x020B, r24
    g_ir_formal.time_one_bit_space  = eeprom_read_word (( uint16_t *) IR_CONFIGURATION_ADD_BIT_ONE_SPACE);
     390:	8a e0       	ldi	r24, 0x0A	; 10
     392:	90 e0       	ldi	r25, 0x00	; 0
     394:	0e 94 b0 0d 	call	0x1b60	; 0x1b60 <__eerd_word_m328>
     398:	90 93 0e 02 	sts	0x020E, r25
     39c:	80 93 0d 02 	sts	0x020D, r24
    g_ir_formal.time_zero_bit_space = eeprom_read_word (( uint16_t *) IR_CONFIGURATION_ADD_BIT_ZERO_SPACE);
     3a0:	8c e0       	ldi	r24, 0x0C	; 12
     3a2:	90 e0       	ldi	r25, 0x00	; 0
     3a4:	0e 94 b0 0d 	call	0x1b60	; 0x1b60 <__eerd_word_m328>
     3a8:	90 93 10 02 	sts	0x0210, r25
     3ac:	80 93 0f 02 	sts	0x020F, r24
    g_ir_formal.data_length         = eeprom_read_word (( uint16_t *) IR_CONFIGURATION_ADD_LENGTH);
     3b0:	8e e0       	ldi	r24, 0x0E	; 14
     3b2:	90 e0       	ldi	r25, 0x00	; 0
     3b4:	0e 94 b0 0d 	call	0x1b60	; 0x1b60 <__eerd_word_m328>
     3b8:	90 93 12 02 	sts	0x0212, r25
     3bc:	80 93 11 02 	sts	0x0211, r24
    g_ir_formal.time_interval       = eeprom_read_word (( uint16_t *) IR_CONFIGURATION_ADD_INTERVAL);
     3c0:	80 e1       	ldi	r24, 0x10	; 16
     3c2:	90 e0       	ldi	r25, 0x00	; 0
     3c4:	0e 94 b0 0d 	call	0x1b60	; 0x1b60 <__eerd_word_m328>
     3c8:	90 93 14 02 	sts	0x0214, r25
     3cc:	80 93 13 02 	sts	0x0213, r24
     3d0:	08 95       	ret

000003d2 <IR_send>:
}

void IR_send(unsigned char  *PtrCommand, unsigned int length)
{
     3d2:	8f 92       	push	r8
     3d4:	9f 92       	push	r9
     3d6:	af 92       	push	r10
     3d8:	bf 92       	push	r11
     3da:	cf 92       	push	r12
     3dc:	df 92       	push	r13
     3de:	ef 92       	push	r14
     3e0:	ff 92       	push	r15
     3e2:	0f 93       	push	r16
     3e4:	1f 93       	push	r17
     3e6:	cf 93       	push	r28
     3e8:	df 93       	push	r29
     3ea:	00 d0       	rcall	.+0      	; 0x3ec <IR_send+0x1a>
     3ec:	00 d0       	rcall	.+0      	; 0x3ee <IR_send+0x1c>
     3ee:	1f 92       	push	r1
     3f0:	cd b7       	in	r28, 0x3d	; 61
     3f2:	de b7       	in	r29, 0x3e	; 62
    g_IR_Send_Index_Data = 0;
     3f4:	10 92 15 02 	sts	0x0215, r1
     
    /*Parse data */
    for (unsigned int i = 0; i< length ; i++)
     3f8:	61 15       	cp	r22, r1
     3fa:	71 05       	cpc	r23, r1
     3fc:	61 f1       	breq	.+88     	; 0x456 <IR_send+0x84>
     3fe:	6c 01       	movw	r12, r24
     400:	5c 01       	movw	r10, r24
     402:	a6 0e       	add	r10, r22
     404:	b7 1e       	adc	r11, r23
    {
        char temp[5] = {};
     406:	0f 2e       	mov	r0, r31
     408:	f5 e0       	ldi	r31, 0x05	; 5
     40a:	9f 2e       	mov	r9, r31
     40c:	f0 2d       	mov	r31, r0
     40e:	ce 01       	movw	r24, r28
     410:	01 96       	adiw	r24, 0x01	; 1
     412:	7c 01       	movw	r14, r24
     414:	8e 01       	movw	r16, r28
     416:	0b 5f       	subi	r16, 0xFB	; 251
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	f7 01       	movw	r30, r14
     41c:	89 2d       	mov	r24, r9
     41e:	11 92       	st	Z+, r1
     420:	8a 95       	dec	r24
     422:	e9 f7       	brne	.-6      	; 0x41e <IR_send+0x4c>
        hex_to_binary(PtrCommand[i],temp);
     424:	b7 01       	movw	r22, r14
     426:	f6 01       	movw	r30, r12
     428:	81 91       	ld	r24, Z+
     42a:	6f 01       	movw	r12, r30
     42c:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <hex_to_binary>
     430:	f7 01       	movw	r30, r14
        for (int j = 0 ; j<4; j++)
        {
            g_IR_Send_Arr_Data[g_IR_Send_Index_Data] = temp[j];
     432:	a0 91 15 02 	lds	r26, 0x0215
     436:	b0 e0       	ldi	r27, 0x00	; 0
     438:	81 91       	ld	r24, Z+
     43a:	a6 5d       	subi	r26, 0xD6	; 214
     43c:	bd 4f       	sbci	r27, 0xFD	; 253
     43e:	8c 93       	st	X, r24
            g_IR_Send_Index_Data++;
     440:	80 91 15 02 	lds	r24, 0x0215
     444:	8f 5f       	subi	r24, 0xFF	; 255
     446:	80 93 15 02 	sts	0x0215, r24
    /*Parse data */
    for (unsigned int i = 0; i< length ; i++)
    {
        char temp[5] = {};
        hex_to_binary(PtrCommand[i],temp);
        for (int j = 0 ; j<4; j++)
     44a:	e0 17       	cp	r30, r16
     44c:	f1 07       	cpc	r31, r17
     44e:	89 f7       	brne	.-30     	; 0x432 <IR_send+0x60>
void IR_send(unsigned char  *PtrCommand, unsigned int length)
{
    g_IR_Send_Index_Data = 0;
     
    /*Parse data */
    for (unsigned int i = 0; i< length ; i++)
     450:	ca 14       	cp	r12, r10
     452:	db 04       	cpc	r13, r11
     454:	11 f7       	brne	.-60     	; 0x41a <IR_send+0x48>
    /*
    *Send data
    */
 
    /*Start bit*/
    Timer2_mark(g_ir_formal.time_start_mark);
     456:	80 91 07 02 	lds	r24, 0x0207
     45a:	90 91 08 02 	lds	r25, 0x0208
     45e:	0e 94 43 01 	call	0x286	; 0x286 <Timer2_mark>
    Timer2_space(g_ir_formal.time_start_space);
     462:	80 91 09 02 	lds	r24, 0x0209
     466:	90 91 0a 02 	lds	r25, 0x020A
     46a:	0e 94 4e 01 	call	0x29c	; 0x29c <Timer2_space>

    /* 4 bytes*/
    for (unsigned int i = 0; i< g_ir_formal.data_length ; i++)
     46e:	80 91 11 02 	lds	r24, 0x0211
     472:	90 91 12 02 	lds	r25, 0x0212
     476:	89 2b       	or	r24, r25
     478:	c1 f1       	breq	.+112    	; 0x4ea <IR_send+0x118>
     47a:	00 e0       	ldi	r16, 0x00	; 0
     47c:	10 e0       	ldi	r17, 0x00	; 0
             (g_ir_formal.time_bit_mark);
            Timer2_space(g_ir_formal.time_one_bit_space);
        }
        else
        {
            Timer2_mark(g_ir_formal.time_bit_mark);
     47e:	0f 2e       	mov	r0, r31
     480:	fb e0       	ldi	r31, 0x0B	; 11
     482:	af 2e       	mov	r10, r31
     484:	f2 e0       	ldi	r31, 0x02	; 2
     486:	bf 2e       	mov	r11, r31
     488:	f0 2d       	mov	r31, r0
            Timer2_space(g_ir_formal.time_zero_bit_space);
     48a:	0f 2e       	mov	r0, r31
     48c:	ff e0       	ldi	r31, 0x0F	; 15
     48e:	cf 2e       	mov	r12, r31
     490:	f2 e0       	ldi	r31, 0x02	; 2
     492:	df 2e       	mov	r13, r31
     494:	f0 2d       	mov	r31, r0
    for (unsigned int i = 0; i< g_ir_formal.data_length ; i++)
    {
        if (g_IR_Send_Arr_Data[i] == '1')
        {
             (g_ir_formal.time_bit_mark);
            Timer2_space(g_ir_formal.time_one_bit_space);
     496:	0f 2e       	mov	r0, r31
     498:	fd e0       	ldi	r31, 0x0D	; 13
     49a:	8f 2e       	mov	r8, r31
     49c:	f2 e0       	ldi	r31, 0x02	; 2
     49e:	9f 2e       	mov	r9, r31
     4a0:	f0 2d       	mov	r31, r0
    /*Start bit*/
    Timer2_mark(g_ir_formal.time_start_mark);
    Timer2_space(g_ir_formal.time_start_space);

    /* 4 bytes*/
    for (unsigned int i = 0; i< g_ir_formal.data_length ; i++)
     4a2:	0f 2e       	mov	r0, r31
     4a4:	f1 e1       	ldi	r31, 0x11	; 17
     4a6:	ef 2e       	mov	r14, r31
     4a8:	f2 e0       	ldi	r31, 0x02	; 2
     4aa:	ff 2e       	mov	r15, r31
     4ac:	f0 2d       	mov	r31, r0
    {
        if (g_IR_Send_Arr_Data[i] == '1')
     4ae:	f8 01       	movw	r30, r16
     4b0:	e6 5d       	subi	r30, 0xD6	; 214
     4b2:	fd 4f       	sbci	r31, 0xFD	; 253
     4b4:	80 81       	ld	r24, Z
     4b6:	81 33       	cpi	r24, 0x31	; 49
     4b8:	31 f4       	brne	.+12     	; 0x4c6 <IR_send+0xf4>
        {
             (g_ir_formal.time_bit_mark);
            Timer2_space(g_ir_formal.time_one_bit_space);
     4ba:	f4 01       	movw	r30, r8
     4bc:	80 81       	ld	r24, Z
     4be:	91 81       	ldd	r25, Z+1	; 0x01
     4c0:	0e 94 4e 01 	call	0x29c	; 0x29c <Timer2_space>
     4c4:	0a c0       	rjmp	.+20     	; 0x4da <IR_send+0x108>
        }
        else
        {
            Timer2_mark(g_ir_formal.time_bit_mark);
     4c6:	f5 01       	movw	r30, r10
     4c8:	80 81       	ld	r24, Z
     4ca:	91 81       	ldd	r25, Z+1	; 0x01
     4cc:	0e 94 43 01 	call	0x286	; 0x286 <Timer2_mark>
            Timer2_space(g_ir_formal.time_zero_bit_space);
     4d0:	f6 01       	movw	r30, r12
     4d2:	80 81       	ld	r24, Z
     4d4:	91 81       	ldd	r25, Z+1	; 0x01
     4d6:	0e 94 4e 01 	call	0x29c	; 0x29c <Timer2_space>
    /*Start bit*/
    Timer2_mark(g_ir_formal.time_start_mark);
    Timer2_space(g_ir_formal.time_start_space);

    /* 4 bytes*/
    for (unsigned int i = 0; i< g_ir_formal.data_length ; i++)
     4da:	0f 5f       	subi	r16, 0xFF	; 255
     4dc:	1f 4f       	sbci	r17, 0xFF	; 255
     4de:	f7 01       	movw	r30, r14
     4e0:	80 81       	ld	r24, Z
     4e2:	91 81       	ldd	r25, Z+1	; 0x01
     4e4:	08 17       	cp	r16, r24
     4e6:	19 07       	cpc	r17, r25
     4e8:	10 f3       	brcs	.-60     	; 0x4ae <IR_send+0xdc>
            Timer2_space(g_ir_formal.time_zero_bit_space);
        }
    }

    /*End bit */
    Timer2_mark(g_ir_formal.time_bit_mark);
     4ea:	80 91 0b 02 	lds	r24, 0x020B
     4ee:	90 91 0c 02 	lds	r25, 0x020C
     4f2:	0e 94 43 01 	call	0x286	; 0x286 <Timer2_mark>
    Timer2_space(0);
     4f6:	80 e0       	ldi	r24, 0x00	; 0
     4f8:	90 e0       	ldi	r25, 0x00	; 0
     4fa:	0e 94 4e 01 	call	0x29c	; 0x29c <Timer2_space>
}
     4fe:	0f 90       	pop	r0
     500:	0f 90       	pop	r0
     502:	0f 90       	pop	r0
     504:	0f 90       	pop	r0
     506:	0f 90       	pop	r0
     508:	df 91       	pop	r29
     50a:	cf 91       	pop	r28
     50c:	1f 91       	pop	r17
     50e:	0f 91       	pop	r16
     510:	ff 90       	pop	r15
     512:	ef 90       	pop	r14
     514:	df 90       	pop	r13
     516:	cf 90       	pop	r12
     518:	bf 90       	pop	r11
     51a:	af 90       	pop	r10
     51c:	9f 90       	pop	r9
     51e:	8f 90       	pop	r8
     520:	08 95       	ret

00000522 <IR_reset>:

void  IR_reset()
{
    g_IR_State = IR_START_COMMAND;
     522:	10 92 28 02 	sts	0x0228, r1
    g_IR_stop = 0;
     526:	10 92 27 02 	sts	0x0227, r1
     52a:	10 92 26 02 	sts	0x0226, r1
    g_IR_possition_hex = 0;
     52e:	10 92 19 02 	sts	0x0219, r1
     532:	10 92 18 02 	sts	0x0218, r1
     536:	08 95       	ret

00000538 <__vector_14>:
/*
*Interrupt service routine
* Timer0 overflow
*/
ISR(TIMER0_COMPA_vect)
{
     538:	1f 92       	push	r1
     53a:	0f 92       	push	r0
     53c:	0f b6       	in	r0, 0x3f	; 63
     53e:	0f 92       	push	r0
     540:	11 24       	eor	r1, r1
     542:	2f 93       	push	r18
     544:	3f 93       	push	r19
     546:	4f 93       	push	r20
     548:	5f 93       	push	r21
     54a:	6f 93       	push	r22
     54c:	7f 93       	push	r23
     54e:	8f 93       	push	r24
     550:	9f 93       	push	r25
     552:	af 93       	push	r26
     554:	bf 93       	push	r27
     556:	ef 93       	push	r30
     558:	ff 93       	push	r31
    g_IR_Time ++;
     55a:	80 91 1a 02 	lds	r24, 0x021A
     55e:	90 91 1b 02 	lds	r25, 0x021B
     562:	01 96       	adiw	r24, 0x01	; 1
     564:	90 93 1b 02 	sts	0x021B, r25
     568:	80 93 1a 02 	sts	0x021A, r24

    if (g_IR_Timeout == 0 && g_IR_Time > g_ir_formal.time_interval)
     56c:	80 91 29 02 	lds	r24, 0x0229
     570:	81 11       	cpse	r24, r1
     572:	10 c0       	rjmp	.+32     	; 0x594 <__vector_14+0x5c>
     574:	80 91 1a 02 	lds	r24, 0x021A
     578:	90 91 1b 02 	lds	r25, 0x021B
     57c:	20 91 13 02 	lds	r18, 0x0213
     580:	30 91 14 02 	lds	r19, 0x0214
     584:	28 17       	cp	r18, r24
     586:	39 07       	cpc	r19, r25
     588:	28 f4       	brcc	.+10     	; 0x594 <__vector_14+0x5c>
    {
        IR_reset();
     58a:	0e 94 91 02 	call	0x522	; 0x522 <IR_reset>
        g_IR_Timeout = -1;
     58e:	8f ef       	ldi	r24, 0xFF	; 255
     590:	80 93 29 02 	sts	0x0229, r24
    }

    g_sleep_microSeconds ++;
     594:	80 91 1c 02 	lds	r24, 0x021C
     598:	90 91 1d 02 	lds	r25, 0x021D
     59c:	01 96       	adiw	r24, 0x01	; 1
     59e:	90 93 1d 02 	sts	0x021D, r25
     5a2:	80 93 1c 02 	sts	0x021C, r24
}
     5a6:	ff 91       	pop	r31
     5a8:	ef 91       	pop	r30
     5aa:	bf 91       	pop	r27
     5ac:	af 91       	pop	r26
     5ae:	9f 91       	pop	r25
     5b0:	8f 91       	pop	r24
     5b2:	7f 91       	pop	r23
     5b4:	6f 91       	pop	r22
     5b6:	5f 91       	pop	r21
     5b8:	4f 91       	pop	r20
     5ba:	3f 91       	pop	r19
     5bc:	2f 91       	pop	r18
     5be:	0f 90       	pop	r0
     5c0:	0f be       	out	0x3f, r0	; 63
     5c2:	0f 90       	pop	r0
     5c4:	1f 90       	pop	r1
     5c6:	18 95       	reti

000005c8 <__vector_1>:
    /*Turn on interrupts*/
    sei();
}

ISR(INT0_vect)
{
     5c8:	1f 92       	push	r1
     5ca:	0f 92       	push	r0
     5cc:	0f b6       	in	r0, 0x3f	; 63
     5ce:	0f 92       	push	r0
     5d0:	11 24       	eor	r1, r1
     5d2:	2f 93       	push	r18
     5d4:	3f 93       	push	r19
     5d6:	4f 93       	push	r20
     5d8:	5f 93       	push	r21
     5da:	6f 93       	push	r22
     5dc:	7f 93       	push	r23
     5de:	8f 93       	push	r24
     5e0:	9f 93       	push	r25
     5e2:	af 93       	push	r26
     5e4:	bf 93       	push	r27
     5e6:	ef 93       	push	r30
     5e8:	ff 93       	push	r31
     5ea:	cf 93       	push	r28
     5ec:	df 93       	push	r29
     5ee:	1f 92       	push	r1
     5f0:	cd b7       	in	r28, 0x3d	; 61
     5f2:	de b7       	in	r29, 0x3e	; 62
    unsigned int TempTime = g_IR_Time;
     5f4:	80 91 1a 02 	lds	r24, 0x021A
     5f8:	90 91 1b 02 	lds	r25, 0x021B

    g_IR_Time = 0;
     5fc:	10 92 1b 02 	sts	0x021B, r1
     600:	10 92 1a 02 	sts	0x021A, r1
    TCNT0 = 0x00;
     604:	16 bc       	out	0x26, r1	; 38
    g_IR_Timeout = 0;
     606:	10 92 29 02 	sts	0x0229, r1

    switch(g_IR_State)
     60a:	20 91 28 02 	lds	r18, 0x0228
     60e:	22 30       	cpi	r18, 0x02	; 2
     610:	71 f1       	breq	.+92     	; 0x66e <__vector_1+0xa6>
     612:	28 f4       	brcc	.+10     	; 0x61e <__vector_1+0x56>
     614:	22 23       	and	r18, r18
     616:	49 f0       	breq	.+18     	; 0x62a <__vector_1+0x62>
     618:	21 30       	cpi	r18, 0x01	; 1
     61a:	99 f0       	breq	.+38     	; 0x642 <__vector_1+0x7a>
     61c:	cc c0       	rjmp	.+408    	; 0x7b6 <__vector_1+0x1ee>
     61e:	23 30       	cpi	r18, 0x03	; 3
     620:	e1 f1       	breq	.+120    	; 0x69a <__vector_1+0xd2>
     622:	24 30       	cpi	r18, 0x04	; 4
     624:	09 f4       	brne	.+2      	; 0x628 <__vector_1+0x60>
     626:	47 c0       	rjmp	.+142    	; 0x6b6 <__vector_1+0xee>
     628:	c6 c0       	rjmp	.+396    	; 0x7b6 <__vector_1+0x1ee>
    {
    case IR_START_COMMAND:
    {
        if (TempTime > g_ir_formal.time_start_command)
     62a:	20 91 05 02 	lds	r18, 0x0205
     62e:	30 91 06 02 	lds	r19, 0x0206
     632:	28 17       	cp	r18, r24
     634:	39 07       	cpc	r19, r25
     636:	08 f0       	brcs	.+2      	; 0x63a <__vector_1+0x72>
     638:	be c0       	rjmp	.+380    	; 0x7b6 <__vector_1+0x1ee>
        {
            g_IR_State = IR_START_MARK;
     63a:	81 e0       	ldi	r24, 0x01	; 1
     63c:	80 93 28 02 	sts	0x0228, r24
     640:	ba c0       	rjmp	.+372    	; 0x7b6 <__vector_1+0x1ee>
		
        break;
    }
    case IR_START_MARK:
    {
        if (TempTime > (g_ir_formal.time_start_mark -50 )
     642:	20 91 07 02 	lds	r18, 0x0207
     646:	30 91 08 02 	lds	r19, 0x0208
     64a:	a9 01       	movw	r20, r18
     64c:	42 53       	subi	r20, 0x32	; 50
     64e:	51 09       	sbc	r21, r1
     650:	48 17       	cp	r20, r24
     652:	59 07       	cpc	r21, r25
     654:	48 f4       	brcc	.+18     	; 0x668 <__vector_1+0xa0>
                && TempTime < (g_ir_formal.time_start_mark +75) )
     656:	25 5b       	subi	r18, 0xB5	; 181
     658:	3f 4f       	sbci	r19, 0xFF	; 255
     65a:	82 17       	cp	r24, r18
     65c:	93 07       	cpc	r25, r19
     65e:	20 f4       	brcc	.+8      	; 0x668 <__vector_1+0xa0>
        {
            g_IR_State = IR_START_SPACE;
     660:	82 e0       	ldi	r24, 0x02	; 2
     662:	80 93 28 02 	sts	0x0228, r24
     666:	a7 c0       	rjmp	.+334    	; 0x7b6 <__vector_1+0x1ee>
        }
        else
        {
            IR_reset();
     668:	0e 94 91 02 	call	0x522	; 0x522 <IR_reset>
     66c:	a4 c0       	rjmp	.+328    	; 0x7b6 <__vector_1+0x1ee>
        break;
    }
    case IR_START_SPACE:
    {
       
        if (TempTime > (g_ir_formal.time_start_space -50) && TempTime <  (g_ir_formal.time_start_space +50))
     66e:	20 91 09 02 	lds	r18, 0x0209
     672:	30 91 0a 02 	lds	r19, 0x020A
     676:	a9 01       	movw	r20, r18
     678:	42 53       	subi	r20, 0x32	; 50
     67a:	51 09       	sbc	r21, r1
     67c:	48 17       	cp	r20, r24
     67e:	59 07       	cpc	r21, r25
     680:	48 f4       	brcc	.+18     	; 0x694 <__vector_1+0xcc>
     682:	2e 5c       	subi	r18, 0xCE	; 206
     684:	3f 4f       	sbci	r19, 0xFF	; 255
     686:	82 17       	cp	r24, r18
     688:	93 07       	cpc	r25, r19
     68a:	20 f4       	brcc	.+8      	; 0x694 <__vector_1+0xcc>
        {
            g_IR_State = IR_BIT_MARK;
     68c:	83 e0       	ldi	r24, 0x03	; 3
     68e:	80 93 28 02 	sts	0x0228, r24
     692:	91 c0       	rjmp	.+290    	; 0x7b6 <__vector_1+0x1ee>
            //USART_Transmits("_",1);
        }
        else
        {
            IR_reset();
     694:	0e 94 91 02 	call	0x522	; 0x522 <IR_reset>
     698:	8e c0       	rjmp	.+284    	; 0x7b6 <__vector_1+0x1ee>
        }
        break;
    }
    case IR_BIT_MARK:
    {
        if ( TempTime <= g_ir_formal.time_start_mark)
     69a:	20 91 07 02 	lds	r18, 0x0207
     69e:	30 91 08 02 	lds	r19, 0x0208
     6a2:	28 17       	cp	r18, r24
     6a4:	39 07       	cpc	r19, r25
     6a6:	20 f0       	brcs	.+8      	; 0x6b0 <__vector_1+0xe8>
        {
            g_IR_State = IR_BIT_SPACE;
     6a8:	84 e0       	ldi	r24, 0x04	; 4
     6aa:	80 93 28 02 	sts	0x0228, r24
     6ae:	83 c0       	rjmp	.+262    	; 0x7b6 <__vector_1+0x1ee>
        }
        else
        {
            IR_reset();
     6b0:	0e 94 91 02 	call	0x522	; 0x522 <IR_reset>
     6b4:	80 c0       	rjmp	.+256    	; 0x7b6 <__vector_1+0x1ee>

        break;
    }
    case IR_BIT_SPACE:
    {
        unsigned int i =  g_IR_stop%4;
     6b6:	20 91 26 02 	lds	r18, 0x0226
     6ba:	30 91 27 02 	lds	r19, 0x0227
     6be:	f9 01       	movw	r30, r18
     6c0:	e3 70       	andi	r30, 0x03	; 3
     6c2:	ff 27       	eor	r31, r31

        if (g_IR_stop > (g_ir_formal.data_length -1) )
     6c4:	20 91 26 02 	lds	r18, 0x0226
     6c8:	30 91 27 02 	lds	r19, 0x0227
     6cc:	40 91 11 02 	lds	r20, 0x0211
     6d0:	50 91 12 02 	lds	r21, 0x0212
     6d4:	41 50       	subi	r20, 0x01	; 1
     6d6:	51 09       	sbc	r21, r1
     6d8:	42 17       	cp	r20, r18
     6da:	53 07       	cpc	r21, r19
     6dc:	18 f4       	brcc	.+6      	; 0x6e4 <__vector_1+0x11c>
        {
            IR_reset();
     6de:	0e 94 91 02 	call	0x522	; 0x522 <IR_reset>
            return;
     6e2:	69 c0       	rjmp	.+210    	; 0x7b6 <__vector_1+0x1ee>
        }

        if (g_ir_formal.time_one_bit_space > g_ir_formal.time_zero_bit_space)
     6e4:	60 91 0d 02 	lds	r22, 0x020D
     6e8:	70 91 0e 02 	lds	r23, 0x020E
     6ec:	40 91 0f 02 	lds	r20, 0x020F
     6f0:	50 91 10 02 	lds	r21, 0x0210
     6f4:	46 17       	cp	r20, r22
     6f6:	57 07       	cpc	r21, r23
     6f8:	90 f4       	brcc	.+36     	; 0x71e <__vector_1+0x156>
        {
            if ( TempTime > (g_ir_formal.time_one_bit_space - 50) )
     6fa:	62 53       	subi	r22, 0x32	; 50
     6fc:	71 09       	sbc	r23, r1
     6fe:	68 17       	cp	r22, r24
     700:	79 07       	cpc	r23, r25
     702:	38 f4       	brcc	.+14     	; 0x712 <__vector_1+0x14a>
            {
                g_IR_data_4bits = (g_IR_data_4bits<<1 ) + 1 ;
     704:	80 91 17 02 	lds	r24, 0x0217
     708:	88 0f       	add	r24, r24
     70a:	8f 5f       	subi	r24, 0xFF	; 255
     70c:	80 93 17 02 	sts	0x0217, r24
     710:	17 c0       	rjmp	.+46     	; 0x740 <__vector_1+0x178>
            }
            else
            {
                g_IR_data_4bits = g_IR_data_4bits<<1 ;
     712:	80 91 17 02 	lds	r24, 0x0217
     716:	88 0f       	add	r24, r24
     718:	80 93 17 02 	sts	0x0217, r24
     71c:	11 c0       	rjmp	.+34     	; 0x740 <__vector_1+0x178>
            }
        }
        else
        {
            if ( TempTime > (g_ir_formal.time_zero_bit_space- 50) )
     71e:	42 53       	subi	r20, 0x32	; 50
     720:	51 09       	sbc	r21, r1
     722:	48 17       	cp	r20, r24
     724:	59 07       	cpc	r21, r25
     726:	38 f4       	brcc	.+14     	; 0x736 <__vector_1+0x16e>
            {
                g_IR_data_4bits = (g_IR_data_4bits<<1 ) + 1 ;
     728:	80 91 17 02 	lds	r24, 0x0217
     72c:	88 0f       	add	r24, r24
     72e:	8f 5f       	subi	r24, 0xFF	; 255
     730:	80 93 17 02 	sts	0x0217, r24
     734:	05 c0       	rjmp	.+10     	; 0x740 <__vector_1+0x178>
            }
            else
            {
                g_IR_data_4bits = g_IR_data_4bits<<1 ;
     736:	80 91 17 02 	lds	r24, 0x0217
     73a:	88 0f       	add	r24, r24
     73c:	80 93 17 02 	sts	0x0217, r24
            }
        }

        if (i == 3)
     740:	33 97       	sbiw	r30, 0x03	; 3
     742:	69 f5       	brne	.+90     	; 0x79e <__vector_1+0x1d6>
        {
            char byte = 0 ;
     744:	19 82       	std	Y+1, r1	; 0x01
            dec_to_hex(g_IR_data_4bits, &byte );
     746:	80 91 17 02 	lds	r24, 0x0217
     74a:	be 01       	movw	r22, r28
     74c:	6f 5f       	subi	r22, 0xFF	; 255
     74e:	7f 4f       	sbci	r23, 0xFF	; 255
     750:	0e 94 c5 05 	call	0xb8a	; 0xb8a <dec_to_hex>
            g_IR_data_4bits = 0;
     754:	10 92 17 02 	sts	0x0217, r1

            g_IR_data_8hexs[g_IR_possition_hex] = byte;
     758:	e0 91 18 02 	lds	r30, 0x0218
     75c:	f0 91 19 02 	lds	r31, 0x0219
     760:	89 81       	ldd	r24, Y+1	; 0x01
     762:	e2 5e       	subi	r30, 0xE2	; 226
     764:	fd 4f       	sbci	r31, 0xFD	; 253
     766:	80 83       	st	Z, r24
            g_IR_possition_hex++;
     768:	80 91 18 02 	lds	r24, 0x0218
     76c:	90 91 19 02 	lds	r25, 0x0219
     770:	01 96       	adiw	r24, 0x01	; 1
     772:	90 93 19 02 	sts	0x0219, r25
     776:	80 93 18 02 	sts	0x0218, r24
            if (g_IR_possition_hex == 8)
     77a:	80 91 18 02 	lds	r24, 0x0218
     77e:	90 91 19 02 	lds	r25, 0x0219
     782:	08 97       	sbiw	r24, 0x08	; 8
     784:	61 f4       	brne	.+24     	; 0x79e <__vector_1+0x1d6>
            {
               USART_Transmits(g_IR_data_8hexs,8);
     786:	68 e0       	ldi	r22, 0x08	; 8
     788:	70 e0       	ldi	r23, 0x00	; 0
     78a:	8e e1       	ldi	r24, 0x1E	; 30
     78c:	92 e0       	ldi	r25, 0x02	; 2
     78e:	0e 94 60 09 	call	0x12c0	; 0x12c0 <USART_Transmits>
			   Light_parse_command(g_IR_data_8hexs,8);
     792:	68 e0       	ldi	r22, 0x08	; 8
     794:	70 e0       	ldi	r23, 0x00	; 0
     796:	8e e1       	ldi	r24, 0x1E	; 30
     798:	92 e0       	ldi	r25, 0x02	; 2
     79a:	0e 94 10 04 	call	0x820	; 0x820 <Light_parse_command>
            }
        }
		
		
        g_IR_State = IR_BIT_MARK;
     79e:	83 e0       	ldi	r24, 0x03	; 3
     7a0:	80 93 28 02 	sts	0x0228, r24
        g_IR_stop ++;
     7a4:	80 91 26 02 	lds	r24, 0x0226
     7a8:	90 91 27 02 	lds	r25, 0x0227
     7ac:	01 96       	adiw	r24, 0x01	; 1
     7ae:	90 93 27 02 	sts	0x0227, r25
     7b2:	80 93 26 02 	sts	0x0226, r24
        break;
	}
	
    }//End switch()
   
}//End function()
     7b6:	0f 90       	pop	r0
     7b8:	df 91       	pop	r29
     7ba:	cf 91       	pop	r28
     7bc:	ff 91       	pop	r31
     7be:	ef 91       	pop	r30
     7c0:	bf 91       	pop	r27
     7c2:	af 91       	pop	r26
     7c4:	9f 91       	pop	r25
     7c6:	8f 91       	pop	r24
     7c8:	7f 91       	pop	r23
     7ca:	6f 91       	pop	r22
     7cc:	5f 91       	pop	r21
     7ce:	4f 91       	pop	r20
     7d0:	3f 91       	pop	r19
     7d2:	2f 91       	pop	r18
     7d4:	0f 90       	pop	r0
     7d6:	0f be       	out	0x3f, r0	; 63
     7d8:	0f 90       	pop	r0
     7da:	1f 90       	pop	r1
     7dc:	18 95       	reti

000007de <Light_init>:
#include "Lighting.h"
#include "Utils.h"

void Light_init()
{
	PinMode(PIN_A0,OUTPUT);
     7de:	61 e0       	ldi	r22, 0x01	; 1
     7e0:	80 e0       	ldi	r24, 0x00	; 0
     7e2:	0e 94 21 0a 	call	0x1442	; 0x1442 <PinMode>
	PinMode(PIN_A1,OUTPUT);
     7e6:	61 e0       	ldi	r22, 0x01	; 1
     7e8:	81 e0       	ldi	r24, 0x01	; 1
     7ea:	0e 94 21 0a 	call	0x1442	; 0x1442 <PinMode>
	PinMode(PIN_A2,OUTPUT);
     7ee:	61 e0       	ldi	r22, 0x01	; 1
     7f0:	82 e0       	ldi	r24, 0x02	; 2
     7f2:	0e 94 21 0a 	call	0x1442	; 0x1442 <PinMode>
	PinMode(PIN_A3,OUTPUT);
     7f6:	61 e0       	ldi	r22, 0x01	; 1
     7f8:	83 e0       	ldi	r24, 0x03	; 3
     7fa:	0e 94 21 0a 	call	0x1442	; 0x1442 <PinMode>
	
	PinWrite(PIN_A0, LOW);
     7fe:	60 e0       	ldi	r22, 0x00	; 0
     800:	80 e0       	ldi	r24, 0x00	; 0
     802:	0e 94 45 0a 	call	0x148a	; 0x148a <PinWrite>
	PinWrite(PIN_A1, LOW);
     806:	60 e0       	ldi	r22, 0x00	; 0
     808:	81 e0       	ldi	r24, 0x01	; 1
     80a:	0e 94 45 0a 	call	0x148a	; 0x148a <PinWrite>
	PinWrite(PIN_A2, LOW);
     80e:	60 e0       	ldi	r22, 0x00	; 0
     810:	82 e0       	ldi	r24, 0x02	; 2
     812:	0e 94 45 0a 	call	0x148a	; 0x148a <PinWrite>
	PinWrite(PIN_A3, LOW);
     816:	60 e0       	ldi	r22, 0x00	; 0
     818:	83 e0       	ldi	r24, 0x03	; 3
     81a:	0e 94 45 0a 	call	0x148a	; 0x148a <PinWrite>
     81e:	08 95       	ret

00000820 <Light_parse_command>:
}


void Light_parse_command(unsigned char *ptrCommand, unsigned int length)
{   
     820:	cf 93       	push	r28
     822:	df 93       	push	r29
     824:	ec 01       	movw	r28, r24
	if ( equal2strUnsignedChars(ptrCommand,(unsigned char *) TUNR_ON_PIN_A0, 8) == 0)
     826:	48 e0       	ldi	r20, 0x08	; 8
     828:	50 e0       	ldi	r21, 0x00	; 0
     82a:	66 e0       	ldi	r22, 0x06	; 6
     82c:	71 e0       	ldi	r23, 0x01	; 1
     82e:	0e 94 4a 07 	call	0xe94	; 0xe94 <equal2strUnsignedChars>
     832:	89 2b       	or	r24, r25
     834:	29 f4       	brne	.+10     	; 0x840 <Light_parse_command+0x20>
	{
		PinWrite(PIN_A0, HIGHT);
     836:	61 e0       	ldi	r22, 0x01	; 1
     838:	80 e0       	ldi	r24, 0x00	; 0
     83a:	0e 94 45 0a 	call	0x148a	; 0x148a <PinWrite>
     83e:	d1 c0       	rjmp	.+418    	; 0x9e2 <__stack+0xe3>
		
	}else  if (equal2strUnsignedChars(ptrCommand,(unsigned char *) TUNR_OFF_PIN_A0, 8) == 0)
     840:	48 e0       	ldi	r20, 0x08	; 8
     842:	50 e0       	ldi	r21, 0x00	; 0
     844:	6f e0       	ldi	r22, 0x0F	; 15
     846:	71 e0       	ldi	r23, 0x01	; 1
     848:	ce 01       	movw	r24, r28
     84a:	0e 94 4a 07 	call	0xe94	; 0xe94 <equal2strUnsignedChars>
     84e:	89 2b       	or	r24, r25
     850:	29 f4       	brne	.+10     	; 0x85c <Light_parse_command+0x3c>
	{
		PinWrite(PIN_A0, LOW);
     852:	60 e0       	ldi	r22, 0x00	; 0
     854:	80 e0       	ldi	r24, 0x00	; 0
     856:	0e 94 45 0a 	call	0x148a	; 0x148a <PinWrite>
     85a:	c3 c0       	rjmp	.+390    	; 0x9e2 <__stack+0xe3>
		
	}else if (equal2strUnsignedChars(ptrCommand,(unsigned char *) TUNR_ON_PIN_A1, 8) == 0)
     85c:	48 e0       	ldi	r20, 0x08	; 8
     85e:	50 e0       	ldi	r21, 0x00	; 0
     860:	68 e1       	ldi	r22, 0x18	; 24
     862:	71 e0       	ldi	r23, 0x01	; 1
     864:	ce 01       	movw	r24, r28
     866:	0e 94 4a 07 	call	0xe94	; 0xe94 <equal2strUnsignedChars>
     86a:	89 2b       	or	r24, r25
     86c:	29 f4       	brne	.+10     	; 0x878 <Light_parse_command+0x58>
	{  
		PinWrite(PIN_A1, HIGHT);
     86e:	61 e0       	ldi	r22, 0x01	; 1
     870:	81 e0       	ldi	r24, 0x01	; 1
     872:	0e 94 45 0a 	call	0x148a	; 0x148a <PinWrite>
     876:	b5 c0       	rjmp	.+362    	; 0x9e2 <__stack+0xe3>
		
	}else if (equal2strUnsignedChars(ptrCommand,(unsigned char *) TUNR_OFF_PIN_A1, 8) == 0)
     878:	48 e0       	ldi	r20, 0x08	; 8
     87a:	50 e0       	ldi	r21, 0x00	; 0
     87c:	61 e2       	ldi	r22, 0x21	; 33
     87e:	71 e0       	ldi	r23, 0x01	; 1
     880:	ce 01       	movw	r24, r28
     882:	0e 94 4a 07 	call	0xe94	; 0xe94 <equal2strUnsignedChars>
     886:	89 2b       	or	r24, r25
     888:	29 f4       	brne	.+10     	; 0x894 <Light_parse_command+0x74>
	{
		PinWrite(PIN_A1, LOW);
     88a:	60 e0       	ldi	r22, 0x00	; 0
     88c:	81 e0       	ldi	r24, 0x01	; 1
     88e:	0e 94 45 0a 	call	0x148a	; 0x148a <PinWrite>
     892:	a7 c0       	rjmp	.+334    	; 0x9e2 <__stack+0xe3>
		
	}else if (equal2strUnsignedChars(ptrCommand,(unsigned char *) TUNR_ON_PIN_A2, 8) == 0)
     894:	48 e0       	ldi	r20, 0x08	; 8
     896:	50 e0       	ldi	r21, 0x00	; 0
     898:	6a e2       	ldi	r22, 0x2A	; 42
     89a:	71 e0       	ldi	r23, 0x01	; 1
     89c:	ce 01       	movw	r24, r28
     89e:	0e 94 4a 07 	call	0xe94	; 0xe94 <equal2strUnsignedChars>
     8a2:	89 2b       	or	r24, r25
     8a4:	29 f4       	brne	.+10     	; 0x8b0 <Light_parse_command+0x90>
	{
		 PinWrite(PIN_A2, HIGHT);
     8a6:	61 e0       	ldi	r22, 0x01	; 1
     8a8:	82 e0       	ldi	r24, 0x02	; 2
     8aa:	0e 94 45 0a 	call	0x148a	; 0x148a <PinWrite>
     8ae:	99 c0       	rjmp	.+306    	; 0x9e2 <__stack+0xe3>
		 
	}else if (equal2strUnsignedChars(ptrCommand,(unsigned char *) TUNR_OFF_PIN_A2, 8) == 0)
     8b0:	48 e0       	ldi	r20, 0x08	; 8
     8b2:	50 e0       	ldi	r21, 0x00	; 0
     8b4:	63 e3       	ldi	r22, 0x33	; 51
     8b6:	71 e0       	ldi	r23, 0x01	; 1
     8b8:	ce 01       	movw	r24, r28
     8ba:	0e 94 4a 07 	call	0xe94	; 0xe94 <equal2strUnsignedChars>
     8be:	89 2b       	or	r24, r25
     8c0:	29 f4       	brne	.+10     	; 0x8cc <Light_parse_command+0xac>
	{
		PinWrite(PIN_A2, LOW);
     8c2:	60 e0       	ldi	r22, 0x00	; 0
     8c4:	82 e0       	ldi	r24, 0x02	; 2
     8c6:	0e 94 45 0a 	call	0x148a	; 0x148a <PinWrite>
     8ca:	8b c0       	rjmp	.+278    	; 0x9e2 <__stack+0xe3>
		
	}else if (equal2strUnsignedChars(ptrCommand,(unsigned char *) TUNR_ON_PIN_A3, 8) == 0)
     8cc:	48 e0       	ldi	r20, 0x08	; 8
     8ce:	50 e0       	ldi	r21, 0x00	; 0
     8d0:	6c e3       	ldi	r22, 0x3C	; 60
     8d2:	71 e0       	ldi	r23, 0x01	; 1
     8d4:	ce 01       	movw	r24, r28
     8d6:	0e 94 4a 07 	call	0xe94	; 0xe94 <equal2strUnsignedChars>
     8da:	89 2b       	or	r24, r25
     8dc:	29 f4       	brne	.+10     	; 0x8e8 <Light_parse_command+0xc8>
	{
		PinWrite(PIN_A3, HIGHT);
     8de:	61 e0       	ldi	r22, 0x01	; 1
     8e0:	83 e0       	ldi	r24, 0x03	; 3
     8e2:	0e 94 45 0a 	call	0x148a	; 0x148a <PinWrite>
     8e6:	7d c0       	rjmp	.+250    	; 0x9e2 <__stack+0xe3>
		
	}else if (equal2strUnsignedChars(ptrCommand,(unsigned char *) TUNR_OFF_PIN_A3, 8) == 0)
     8e8:	48 e0       	ldi	r20, 0x08	; 8
     8ea:	50 e0       	ldi	r21, 0x00	; 0
     8ec:	65 e4       	ldi	r22, 0x45	; 69
     8ee:	71 e0       	ldi	r23, 0x01	; 1
     8f0:	ce 01       	movw	r24, r28
     8f2:	0e 94 4a 07 	call	0xe94	; 0xe94 <equal2strUnsignedChars>
     8f6:	89 2b       	or	r24, r25
     8f8:	29 f4       	brne	.+10     	; 0x904 <__stack+0x5>
	{
		PinWrite(PIN_A3, LOW);
     8fa:	60 e0       	ldi	r22, 0x00	; 0
     8fc:	83 e0       	ldi	r24, 0x03	; 3
     8fe:	0e 94 45 0a 	call	0x148a	; 0x148a <PinWrite>
     902:	6f c0       	rjmp	.+222    	; 0x9e2 <__stack+0xe3>
		/*Remote SAMSUNG*/
	}else if (equal2strUnsignedChars(ptrCommand,(unsigned char *) TUNR_ON_PIN0_Test, 8) == 0)
     904:	48 e0       	ldi	r20, 0x08	; 8
     906:	50 e0       	ldi	r21, 0x00	; 0
     908:	6e e4       	ldi	r22, 0x4E	; 78
     90a:	71 e0       	ldi	r23, 0x01	; 1
     90c:	ce 01       	movw	r24, r28
     90e:	0e 94 4a 07 	call	0xe94	; 0xe94 <equal2strUnsignedChars>
     912:	89 2b       	or	r24, r25
     914:	29 f4       	brne	.+10     	; 0x920 <__stack+0x21>
	{
		PinWrite(PIN_A0, HIGHT);
     916:	61 e0       	ldi	r22, 0x01	; 1
     918:	80 e0       	ldi	r24, 0x00	; 0
     91a:	0e 94 45 0a 	call	0x148a	; 0x148a <PinWrite>
     91e:	61 c0       	rjmp	.+194    	; 0x9e2 <__stack+0xe3>
		
    }else if (equal2strUnsignedChars(ptrCommand,(unsigned char *) TUNR_OFF_PIN0_Test, 8) == 0)
     920:	48 e0       	ldi	r20, 0x08	; 8
     922:	50 e0       	ldi	r21, 0x00	; 0
     924:	67 e5       	ldi	r22, 0x57	; 87
     926:	71 e0       	ldi	r23, 0x01	; 1
     928:	ce 01       	movw	r24, r28
     92a:	0e 94 4a 07 	call	0xe94	; 0xe94 <equal2strUnsignedChars>
     92e:	89 2b       	or	r24, r25
     930:	29 f4       	brne	.+10     	; 0x93c <__stack+0x3d>
    {
	   PinWrite(PIN_A0, LOW);
     932:	60 e0       	ldi	r22, 0x00	; 0
     934:	80 e0       	ldi	r24, 0x00	; 0
     936:	0e 94 45 0a 	call	0x148a	; 0x148a <PinWrite>
     93a:	53 c0       	rjmp	.+166    	; 0x9e2 <__stack+0xe3>
	   
    }else if (equal2strUnsignedChars(ptrCommand,(unsigned char *) TUNR_ON_PIN1_Test, 8) == 0)
     93c:	48 e0       	ldi	r20, 0x08	; 8
     93e:	50 e0       	ldi	r21, 0x00	; 0
     940:	60 e6       	ldi	r22, 0x60	; 96
     942:	71 e0       	ldi	r23, 0x01	; 1
     944:	ce 01       	movw	r24, r28
     946:	0e 94 4a 07 	call	0xe94	; 0xe94 <equal2strUnsignedChars>
     94a:	89 2b       	or	r24, r25
     94c:	29 f4       	brne	.+10     	; 0x958 <__stack+0x59>
    {
		PinWrite(PIN_A1, HIGHT);
     94e:	61 e0       	ldi	r22, 0x01	; 1
     950:	81 e0       	ldi	r24, 0x01	; 1
     952:	0e 94 45 0a 	call	0x148a	; 0x148a <PinWrite>
     956:	45 c0       	rjmp	.+138    	; 0x9e2 <__stack+0xe3>
		
    }else  if (equal2strUnsignedChars(ptrCommand,(unsigned char *) TUNR_OFF_PIN1_Test, 8) == 0)
     958:	48 e0       	ldi	r20, 0x08	; 8
     95a:	50 e0       	ldi	r21, 0x00	; 0
     95c:	69 e6       	ldi	r22, 0x69	; 105
     95e:	71 e0       	ldi	r23, 0x01	; 1
     960:	ce 01       	movw	r24, r28
     962:	0e 94 4a 07 	call	0xe94	; 0xe94 <equal2strUnsignedChars>
     966:	89 2b       	or	r24, r25
     968:	29 f4       	brne	.+10     	; 0x974 <__stack+0x75>
    {
		PinWrite(PIN_A1, LOW);
     96a:	60 e0       	ldi	r22, 0x00	; 0
     96c:	81 e0       	ldi	r24, 0x01	; 1
     96e:	0e 94 45 0a 	call	0x148a	; 0x148a <PinWrite>
     972:	37 c0       	rjmp	.+110    	; 0x9e2 <__stack+0xe3>
		
    }else if (equal2strUnsignedChars(ptrCommand,(unsigned char *) TUNR_ON_PIN2_Test, 8) == 0)
     974:	48 e0       	ldi	r20, 0x08	; 8
     976:	50 e0       	ldi	r21, 0x00	; 0
     978:	62 e7       	ldi	r22, 0x72	; 114
     97a:	71 e0       	ldi	r23, 0x01	; 1
     97c:	ce 01       	movw	r24, r28
     97e:	0e 94 4a 07 	call	0xe94	; 0xe94 <equal2strUnsignedChars>
     982:	89 2b       	or	r24, r25
     984:	29 f4       	brne	.+10     	; 0x990 <__stack+0x91>
    {
		PinWrite(PIN_A2, HIGHT);
     986:	61 e0       	ldi	r22, 0x01	; 1
     988:	82 e0       	ldi	r24, 0x02	; 2
     98a:	0e 94 45 0a 	call	0x148a	; 0x148a <PinWrite>
     98e:	29 c0       	rjmp	.+82     	; 0x9e2 <__stack+0xe3>
		
    }else if(equal2strUnsignedChars(ptrCommand,(unsigned char *) TUNR_OFF_PIN2_Test, 8) == 0)
     990:	48 e0       	ldi	r20, 0x08	; 8
     992:	50 e0       	ldi	r21, 0x00	; 0
     994:	6b e7       	ldi	r22, 0x7B	; 123
     996:	71 e0       	ldi	r23, 0x01	; 1
     998:	ce 01       	movw	r24, r28
     99a:	0e 94 4a 07 	call	0xe94	; 0xe94 <equal2strUnsignedChars>
     99e:	89 2b       	or	r24, r25
     9a0:	29 f4       	brne	.+10     	; 0x9ac <__stack+0xad>
	{
		PinWrite(PIN_A2, LOW);
     9a2:	60 e0       	ldi	r22, 0x00	; 0
     9a4:	82 e0       	ldi	r24, 0x02	; 2
     9a6:	0e 94 45 0a 	call	0x148a	; 0x148a <PinWrite>
     9aa:	1b c0       	rjmp	.+54     	; 0x9e2 <__stack+0xe3>
		
	}else if (equal2strUnsignedChars(ptrCommand,(unsigned char *) TUNR_ON_PIN3_Test, 8) == 0)
     9ac:	48 e0       	ldi	r20, 0x08	; 8
     9ae:	50 e0       	ldi	r21, 0x00	; 0
     9b0:	64 e8       	ldi	r22, 0x84	; 132
     9b2:	71 e0       	ldi	r23, 0x01	; 1
     9b4:	ce 01       	movw	r24, r28
     9b6:	0e 94 4a 07 	call	0xe94	; 0xe94 <equal2strUnsignedChars>
     9ba:	89 2b       	or	r24, r25
     9bc:	29 f4       	brne	.+10     	; 0x9c8 <__stack+0xc9>
	{
		PinWrite(PIN_A3, HIGHT);
     9be:	61 e0       	ldi	r22, 0x01	; 1
     9c0:	83 e0       	ldi	r24, 0x03	; 3
     9c2:	0e 94 45 0a 	call	0x148a	; 0x148a <PinWrite>
     9c6:	0d c0       	rjmp	.+26     	; 0x9e2 <__stack+0xe3>
		
	}else if (equal2strUnsignedChars(ptrCommand,(unsigned char *) TUNR_OFF_PIN3_Test, 8) == 0)
     9c8:	48 e0       	ldi	r20, 0x08	; 8
     9ca:	50 e0       	ldi	r21, 0x00	; 0
     9cc:	6d e8       	ldi	r22, 0x8D	; 141
     9ce:	71 e0       	ldi	r23, 0x01	; 1
     9d0:	ce 01       	movw	r24, r28
     9d2:	0e 94 4a 07 	call	0xe94	; 0xe94 <equal2strUnsignedChars>
     9d6:	89 2b       	or	r24, r25
     9d8:	21 f4       	brne	.+8      	; 0x9e2 <__stack+0xe3>
	{
		PinWrite(PIN_A3, LOW);
     9da:	60 e0       	ldi	r22, 0x00	; 0
     9dc:	83 e0       	ldi	r24, 0x03	; 3
     9de:	0e 94 45 0a 	call	0x148a	; 0x148a <PinWrite>
	}
}
     9e2:	df 91       	pop	r29
     9e4:	cf 91       	pop	r28
     9e6:	08 95       	ret

000009e8 <hex_to_binary>:
	}
}

void hex_to_binary(const char hex, char *bin)
{
	switch(hex)
     9e8:	90 e0       	ldi	r25, 0x00	; 0
     9ea:	fc 01       	movw	r30, r24
     9ec:	f0 97       	sbiw	r30, 0x30	; 48
     9ee:	e7 33       	cpi	r30, 0x37	; 55
     9f0:	f1 05       	cpc	r31, r1
     9f2:	08 f0       	brcs	.+2      	; 0x9f6 <hex_to_binary+0xe>
     9f4:	c9 c0       	rjmp	.+402    	; 0xb88 <hex_to_binary+0x1a0>
     9f6:	ec 5c       	subi	r30, 0xCC	; 204
     9f8:	ff 4f       	sbci	r31, 0xFF	; 255
     9fa:	0c 94 87 0a 	jmp	0x150e	; 0x150e <__tablejump2__>
	{
		case '0':
		strcpy(bin,"0000");
     9fe:	85 e0       	ldi	r24, 0x05	; 5
     a00:	e6 e9       	ldi	r30, 0x96	; 150
     a02:	f1 e0       	ldi	r31, 0x01	; 1
     a04:	db 01       	movw	r26, r22
     a06:	01 90       	ld	r0, Z+
     a08:	0d 92       	st	X+, r0
     a0a:	8a 95       	dec	r24
     a0c:	e1 f7       	brne	.-8      	; 0xa06 <hex_to_binary+0x1e>
		break;
     a0e:	08 95       	ret
		case '1':
		strcpy(bin,"0001");
     a10:	85 e0       	ldi	r24, 0x05	; 5
     a12:	eb e9       	ldi	r30, 0x9B	; 155
     a14:	f1 e0       	ldi	r31, 0x01	; 1
     a16:	db 01       	movw	r26, r22
     a18:	01 90       	ld	r0, Z+
     a1a:	0d 92       	st	X+, r0
     a1c:	8a 95       	dec	r24
     a1e:	e1 f7       	brne	.-8      	; 0xa18 <hex_to_binary+0x30>
		break;
     a20:	08 95       	ret
		case '2':
		strcpy(bin,"0010");
     a22:	85 e0       	ldi	r24, 0x05	; 5
     a24:	e0 ea       	ldi	r30, 0xA0	; 160
     a26:	f1 e0       	ldi	r31, 0x01	; 1
     a28:	db 01       	movw	r26, r22
     a2a:	01 90       	ld	r0, Z+
     a2c:	0d 92       	st	X+, r0
     a2e:	8a 95       	dec	r24
     a30:	e1 f7       	brne	.-8      	; 0xa2a <hex_to_binary+0x42>
		break;
     a32:	08 95       	ret
		case '3':
		strcpy(bin,"0011");
     a34:	85 e0       	ldi	r24, 0x05	; 5
     a36:	e5 ea       	ldi	r30, 0xA5	; 165
     a38:	f1 e0       	ldi	r31, 0x01	; 1
     a3a:	db 01       	movw	r26, r22
     a3c:	01 90       	ld	r0, Z+
     a3e:	0d 92       	st	X+, r0
     a40:	8a 95       	dec	r24
     a42:	e1 f7       	brne	.-8      	; 0xa3c <hex_to_binary+0x54>
		break;
     a44:	08 95       	ret
		case '4':
		strcpy(bin,"0100");
     a46:	85 e0       	ldi	r24, 0x05	; 5
     a48:	ea ea       	ldi	r30, 0xAA	; 170
     a4a:	f1 e0       	ldi	r31, 0x01	; 1
     a4c:	db 01       	movw	r26, r22
     a4e:	01 90       	ld	r0, Z+
     a50:	0d 92       	st	X+, r0
     a52:	8a 95       	dec	r24
     a54:	e1 f7       	brne	.-8      	; 0xa4e <hex_to_binary+0x66>
		break;
     a56:	08 95       	ret
		case '5':
		strcpy(bin,"0101");
     a58:	85 e0       	ldi	r24, 0x05	; 5
     a5a:	ef ea       	ldi	r30, 0xAF	; 175
     a5c:	f1 e0       	ldi	r31, 0x01	; 1
     a5e:	db 01       	movw	r26, r22
     a60:	01 90       	ld	r0, Z+
     a62:	0d 92       	st	X+, r0
     a64:	8a 95       	dec	r24
     a66:	e1 f7       	brne	.-8      	; 0xa60 <hex_to_binary+0x78>
		break;
     a68:	08 95       	ret
		case '6':
		strcpy(bin,"0110");
     a6a:	85 e0       	ldi	r24, 0x05	; 5
     a6c:	e4 eb       	ldi	r30, 0xB4	; 180
     a6e:	f1 e0       	ldi	r31, 0x01	; 1
     a70:	db 01       	movw	r26, r22
     a72:	01 90       	ld	r0, Z+
     a74:	0d 92       	st	X+, r0
     a76:	8a 95       	dec	r24
     a78:	e1 f7       	brne	.-8      	; 0xa72 <hex_to_binary+0x8a>
		break;
     a7a:	08 95       	ret
		case '7':
		strcpy(bin,"0111");
     a7c:	85 e0       	ldi	r24, 0x05	; 5
     a7e:	e9 eb       	ldi	r30, 0xB9	; 185
     a80:	f1 e0       	ldi	r31, 0x01	; 1
     a82:	db 01       	movw	r26, r22
     a84:	01 90       	ld	r0, Z+
     a86:	0d 92       	st	X+, r0
     a88:	8a 95       	dec	r24
     a8a:	e1 f7       	brne	.-8      	; 0xa84 <hex_to_binary+0x9c>
		break;
     a8c:	08 95       	ret
		case '8':
		strcpy(bin,"1000");
     a8e:	85 e0       	ldi	r24, 0x05	; 5
     a90:	ee eb       	ldi	r30, 0xBE	; 190
     a92:	f1 e0       	ldi	r31, 0x01	; 1
     a94:	db 01       	movw	r26, r22
     a96:	01 90       	ld	r0, Z+
     a98:	0d 92       	st	X+, r0
     a9a:	8a 95       	dec	r24
     a9c:	e1 f7       	brne	.-8      	; 0xa96 <hex_to_binary+0xae>
		break;
     a9e:	08 95       	ret
		case '9':
		strcpy(bin,"1001");
     aa0:	85 e0       	ldi	r24, 0x05	; 5
     aa2:	e3 ec       	ldi	r30, 0xC3	; 195
     aa4:	f1 e0       	ldi	r31, 0x01	; 1
     aa6:	db 01       	movw	r26, r22
     aa8:	01 90       	ld	r0, Z+
     aaa:	0d 92       	st	X+, r0
     aac:	8a 95       	dec	r24
     aae:	e1 f7       	brne	.-8      	; 0xaa8 <hex_to_binary+0xc0>
		break;
     ab0:	08 95       	ret
		case 'A':
		strcpy(bin,"1010");
     ab2:	85 e0       	ldi	r24, 0x05	; 5
     ab4:	e8 ec       	ldi	r30, 0xC8	; 200
     ab6:	f1 e0       	ldi	r31, 0x01	; 1
     ab8:	db 01       	movw	r26, r22
     aba:	01 90       	ld	r0, Z+
     abc:	0d 92       	st	X+, r0
     abe:	8a 95       	dec	r24
     ac0:	e1 f7       	brne	.-8      	; 0xaba <hex_to_binary+0xd2>
		break;
     ac2:	08 95       	ret
		case 'B':
		strcpy(bin,"1011");
     ac4:	85 e0       	ldi	r24, 0x05	; 5
     ac6:	ed ec       	ldi	r30, 0xCD	; 205
     ac8:	f1 e0       	ldi	r31, 0x01	; 1
     aca:	db 01       	movw	r26, r22
     acc:	01 90       	ld	r0, Z+
     ace:	0d 92       	st	X+, r0
     ad0:	8a 95       	dec	r24
     ad2:	e1 f7       	brne	.-8      	; 0xacc <hex_to_binary+0xe4>
		break;
     ad4:	08 95       	ret
		case 'C':
		strcpy(bin,"1100");
     ad6:	85 e0       	ldi	r24, 0x05	; 5
     ad8:	e2 ed       	ldi	r30, 0xD2	; 210
     ada:	f1 e0       	ldi	r31, 0x01	; 1
     adc:	db 01       	movw	r26, r22
     ade:	01 90       	ld	r0, Z+
     ae0:	0d 92       	st	X+, r0
     ae2:	8a 95       	dec	r24
     ae4:	e1 f7       	brne	.-8      	; 0xade <hex_to_binary+0xf6>
		break;
     ae6:	08 95       	ret
		case 'D':
		strcpy(bin,"1101");
     ae8:	85 e0       	ldi	r24, 0x05	; 5
     aea:	e7 ed       	ldi	r30, 0xD7	; 215
     aec:	f1 e0       	ldi	r31, 0x01	; 1
     aee:	db 01       	movw	r26, r22
     af0:	01 90       	ld	r0, Z+
     af2:	0d 92       	st	X+, r0
     af4:	8a 95       	dec	r24
     af6:	e1 f7       	brne	.-8      	; 0xaf0 <hex_to_binary+0x108>
		break;
     af8:	08 95       	ret
		case 'E':
		strcpy(bin,"1110");
     afa:	85 e0       	ldi	r24, 0x05	; 5
     afc:	ec ed       	ldi	r30, 0xDC	; 220
     afe:	f1 e0       	ldi	r31, 0x01	; 1
     b00:	db 01       	movw	r26, r22
     b02:	01 90       	ld	r0, Z+
     b04:	0d 92       	st	X+, r0
     b06:	8a 95       	dec	r24
     b08:	e1 f7       	brne	.-8      	; 0xb02 <hex_to_binary+0x11a>
		break;
     b0a:	08 95       	ret
		case 'F':
		strcpy(bin,"1111");
     b0c:	85 e0       	ldi	r24, 0x05	; 5
     b0e:	e1 ee       	ldi	r30, 0xE1	; 225
     b10:	f1 e0       	ldi	r31, 0x01	; 1
     b12:	db 01       	movw	r26, r22
     b14:	01 90       	ld	r0, Z+
     b16:	0d 92       	st	X+, r0
     b18:	8a 95       	dec	r24
     b1a:	e1 f7       	brne	.-8      	; 0xb14 <hex_to_binary+0x12c>
		break;
     b1c:	08 95       	ret
		case 'a':
		strcpy(bin,"1010");
     b1e:	85 e0       	ldi	r24, 0x05	; 5
     b20:	e8 ec       	ldi	r30, 0xC8	; 200
     b22:	f1 e0       	ldi	r31, 0x01	; 1
     b24:	db 01       	movw	r26, r22
     b26:	01 90       	ld	r0, Z+
     b28:	0d 92       	st	X+, r0
     b2a:	8a 95       	dec	r24
     b2c:	e1 f7       	brne	.-8      	; 0xb26 <hex_to_binary+0x13e>
		break;
     b2e:	08 95       	ret
		case 'b':
		strcpy(bin,"1011");
     b30:	85 e0       	ldi	r24, 0x05	; 5
     b32:	ed ec       	ldi	r30, 0xCD	; 205
     b34:	f1 e0       	ldi	r31, 0x01	; 1
     b36:	db 01       	movw	r26, r22
     b38:	01 90       	ld	r0, Z+
     b3a:	0d 92       	st	X+, r0
     b3c:	8a 95       	dec	r24
     b3e:	e1 f7       	brne	.-8      	; 0xb38 <hex_to_binary+0x150>
		break;
     b40:	08 95       	ret
		case 'c':
		strcpy(bin,"1100");
     b42:	85 e0       	ldi	r24, 0x05	; 5
     b44:	e2 ed       	ldi	r30, 0xD2	; 210
     b46:	f1 e0       	ldi	r31, 0x01	; 1
     b48:	db 01       	movw	r26, r22
     b4a:	01 90       	ld	r0, Z+
     b4c:	0d 92       	st	X+, r0
     b4e:	8a 95       	dec	r24
     b50:	e1 f7       	brne	.-8      	; 0xb4a <hex_to_binary+0x162>
		break;
     b52:	08 95       	ret
		case 'd':
		strcpy(bin,"1101");
     b54:	85 e0       	ldi	r24, 0x05	; 5
     b56:	e7 ed       	ldi	r30, 0xD7	; 215
     b58:	f1 e0       	ldi	r31, 0x01	; 1
     b5a:	db 01       	movw	r26, r22
     b5c:	01 90       	ld	r0, Z+
     b5e:	0d 92       	st	X+, r0
     b60:	8a 95       	dec	r24
     b62:	e1 f7       	brne	.-8      	; 0xb5c <hex_to_binary+0x174>
		break;
     b64:	08 95       	ret
		case 'e':
		strcpy(bin,"1110");
     b66:	85 e0       	ldi	r24, 0x05	; 5
     b68:	ec ed       	ldi	r30, 0xDC	; 220
     b6a:	f1 e0       	ldi	r31, 0x01	; 1
     b6c:	db 01       	movw	r26, r22
     b6e:	01 90       	ld	r0, Z+
     b70:	0d 92       	st	X+, r0
     b72:	8a 95       	dec	r24
     b74:	e1 f7       	brne	.-8      	; 0xb6e <hex_to_binary+0x186>
		break;
     b76:	08 95       	ret
		case 'f':
		strcpy(bin,"1111");
     b78:	85 e0       	ldi	r24, 0x05	; 5
     b7a:	e1 ee       	ldi	r30, 0xE1	; 225
     b7c:	f1 e0       	ldi	r31, 0x01	; 1
     b7e:	db 01       	movw	r26, r22
     b80:	01 90       	ld	r0, Z+
     b82:	0d 92       	st	X+, r0
     b84:	8a 95       	dec	r24
     b86:	e1 f7       	brne	.-8      	; 0xb80 <hex_to_binary+0x198>
     b88:	08 95       	ret

00000b8a <dec_to_hex>:
	}
}

void dec_to_hex(const unsigned char dec , char *hex)
{
	if(dec < 10)
     b8a:	8a 30       	cpi	r24, 0x0A	; 10
     b8c:	20 f4       	brcc	.+8      	; 0xb96 <dec_to_hex+0xc>
	{
		*hex = dec + '0';
     b8e:	80 5d       	subi	r24, 0xD0	; 208
     b90:	fb 01       	movw	r30, r22
     b92:	80 83       	st	Z, r24
     b94:	08 95       	ret
	}
	else
	{
		if(dec<16)
     b96:	80 31       	cpi	r24, 0x10	; 16
     b98:	80 f4       	brcc	.+32     	; 0xbba <dec_to_hex+0x30>
		{
			*hex = (dec%10)+ 'A';
     b9a:	9d ec       	ldi	r25, 0xCD	; 205
     b9c:	89 9f       	mul	r24, r25
     b9e:	91 2d       	mov	r25, r1
     ba0:	11 24       	eor	r1, r1
     ba2:	96 95       	lsr	r25
     ba4:	96 95       	lsr	r25
     ba6:	96 95       	lsr	r25
     ba8:	99 0f       	add	r25, r25
     baa:	29 2f       	mov	r18, r25
     bac:	22 0f       	add	r18, r18
     bae:	22 0f       	add	r18, r18
     bb0:	92 0f       	add	r25, r18
     bb2:	89 1b       	sub	r24, r25
     bb4:	8f 5b       	subi	r24, 0xBF	; 191
     bb6:	fb 01       	movw	r30, r22
     bb8:	80 83       	st	Z, r24
     bba:	08 95       	ret

00000bbc <ascii_to_hex>:
		}
	}
}

void ascii_to_hex(const unsigned char *chr,char *hex)
{
     bbc:	ff 92       	push	r15
     bbe:	0f 93       	push	r16
     bc0:	1f 93       	push	r17
     bc2:	cf 93       	push	r28
     bc4:	df 93       	push	r29
     bc6:	1f 92       	push	r1
     bc8:	cd b7       	in	r28, 0x3d	; 61
     bca:	de b7       	in	r29, 0x3e	; 62
     bcc:	8b 01       	movw	r16, r22
	unsigned char firstHex =(*chr)>>4;
     bce:	fc 01       	movw	r30, r24
     bd0:	f0 80       	ld	r15, Z
	unsigned char lastHex = ((*chr)<<4);
	lastHex =lastHex>>4;
	if( (hex != '\0') && (hex+1 != '\0') )
     bd2:	61 15       	cp	r22, r1
     bd4:	71 05       	cpc	r23, r1
     bd6:	c9 f0       	breq	.+50     	; 0xc0a <ascii_to_hex+0x4e>
     bd8:	6f 3f       	cpi	r22, 0xFF	; 255
     bda:	ff ef       	ldi	r31, 0xFF	; 255
     bdc:	7f 07       	cpc	r23, r31
     bde:	a9 f0       	breq	.+42     	; 0xc0a <ascii_to_hex+0x4e>
	{
		char hextemp;
		dec_to_hex(firstHex, &hextemp);
     be0:	be 01       	movw	r22, r28
     be2:	6f 5f       	subi	r22, 0xFF	; 255
     be4:	7f 4f       	sbci	r23, 0xFF	; 255
     be6:	8f 2d       	mov	r24, r15
     be8:	82 95       	swap	r24
     bea:	8f 70       	andi	r24, 0x0F	; 15
     bec:	0e 94 c5 05 	call	0xb8a	; 0xb8a <dec_to_hex>
		*hex = hextemp;
     bf0:	89 81       	ldd	r24, Y+1	; 0x01
     bf2:	f8 01       	movw	r30, r16
     bf4:	80 83       	st	Z, r24
		dec_to_hex(lastHex, &hextemp);
     bf6:	be 01       	movw	r22, r28
     bf8:	6f 5f       	subi	r22, 0xFF	; 255
     bfa:	7f 4f       	sbci	r23, 0xFF	; 255
     bfc:	8f 2d       	mov	r24, r15
     bfe:	8f 70       	andi	r24, 0x0F	; 15
     c00:	0e 94 c5 05 	call	0xb8a	; 0xb8a <dec_to_hex>
		*(hex+1) = hextemp;
     c04:	89 81       	ldd	r24, Y+1	; 0x01
     c06:	f8 01       	movw	r30, r16
     c08:	81 83       	std	Z+1, r24	; 0x01
	}
}
     c0a:	0f 90       	pop	r0
     c0c:	df 91       	pop	r29
     c0e:	cf 91       	pop	r28
     c10:	1f 91       	pop	r17
     c12:	0f 91       	pop	r16
     c14:	ff 90       	pop	r15
     c16:	08 95       	ret

00000c18 <string_to_hex>:

void string_to_hex(const unsigned char *chr, unsigned int length, char *hex)
{
     c18:	cf 92       	push	r12
     c1a:	df 92       	push	r13
     c1c:	ef 92       	push	r14
     c1e:	ff 92       	push	r15
     c20:	0f 93       	push	r16
     c22:	1f 93       	push	r17
     c24:	cf 93       	push	r28
     c26:	df 93       	push	r29
     c28:	00 d0       	rcall	.+0      	; 0xc2a <string_to_hex+0x12>
     c2a:	1f 92       	push	r1
     c2c:	cd b7       	in	r28, 0x3d	; 61
     c2e:	de b7       	in	r29, 0x3e	; 62
     c30:	8c 01       	movw	r16, r24
     c32:	7a 01       	movw	r14, r20
	for(unsigned int i = 0; i< length; i++)
     c34:	61 15       	cp	r22, r1
     c36:	71 05       	cpc	r23, r1
     c38:	c9 f0       	breq	.+50     	; 0xc6c <string_to_hex+0x54>
     c3a:	6c 01       	movw	r12, r24
     c3c:	c6 0e       	add	r12, r22
     c3e:	d7 1e       	adc	r13, r23
	{
		char buffer[3] = {0};
     c40:	19 82       	std	Y+1, r1	; 0x01
     c42:	1a 82       	std	Y+2, r1	; 0x02
     c44:	1b 82       	std	Y+3, r1	; 0x03
		ascii_to_hex(chr,buffer);
     c46:	be 01       	movw	r22, r28
     c48:	6f 5f       	subi	r22, 0xFF	; 255
     c4a:	7f 4f       	sbci	r23, 0xFF	; 255
     c4c:	c8 01       	movw	r24, r16
     c4e:	0e 94 de 05 	call	0xbbc	; 0xbbc <ascii_to_hex>

		*hex = buffer[0] ;
     c52:	89 81       	ldd	r24, Y+1	; 0x01
     c54:	f7 01       	movw	r30, r14
     c56:	80 83       	st	Z, r24
		hex++;
		*hex = buffer[1] ;
     c58:	8a 81       	ldd	r24, Y+2	; 0x02
     c5a:	81 83       	std	Z+1, r24	; 0x01
     c5c:	f2 e0       	ldi	r31, 0x02	; 2
     c5e:	ef 0e       	add	r14, r31
     c60:	f1 1c       	adc	r15, r1
		hex++;

		chr++;
     c62:	0f 5f       	subi	r16, 0xFF	; 255
     c64:	1f 4f       	sbci	r17, 0xFF	; 255
	}
}

void string_to_hex(const unsigned char *chr, unsigned int length, char *hex)
{
	for(unsigned int i = 0; i< length; i++)
     c66:	0c 15       	cp	r16, r12
     c68:	1d 05       	cpc	r17, r13
     c6a:	51 f7       	brne	.-44     	; 0xc40 <string_to_hex+0x28>
		*hex = buffer[1] ;
		hex++;

		chr++;
	}
}
     c6c:	0f 90       	pop	r0
     c6e:	0f 90       	pop	r0
     c70:	0f 90       	pop	r0
     c72:	df 91       	pop	r29
     c74:	cf 91       	pop	r28
     c76:	1f 91       	pop	r17
     c78:	0f 91       	pop	r16
     c7a:	ff 90       	pop	r15
     c7c:	ef 90       	pop	r14
     c7e:	df 90       	pop	r13
     c80:	cf 90       	pop	r12
     c82:	08 95       	ret

00000c84 <binary_to_ascii>:

void binary_to_ascii(const char *bin, unsigned char *value)
{
     c84:	cf 93       	push	r28
     c86:	df 93       	push	r29
     c88:	eb 01       	movw	r28, r22
	int last =  strlen(bin);
     c8a:	dc 01       	movw	r26, r24
     c8c:	0d 90       	ld	r0, X+
     c8e:	00 20       	and	r0, r0
     c90:	e9 f7       	brne	.-6      	; 0xc8c <binary_to_ascii+0x8>
     c92:	11 97       	sbiw	r26, 0x01	; 1
     c94:	a8 1b       	sub	r26, r24
     c96:	b9 0b       	sbc	r27, r25
	*value = 0;
     c98:	18 82       	st	Y, r1
	int tem  = SCHAR_MAX +1 ;//128
	for(  int i= 0 ; i< last; i++)
     c9a:	1a 16       	cp	r1, r26
     c9c:	1b 06       	cpc	r1, r27
     c9e:	94 f4       	brge	.+36     	; 0xcc4 <binary_to_ascii+0x40>
     ca0:	fc 01       	movw	r30, r24
     ca2:	20 e0       	ldi	r18, 0x00	; 0
     ca4:	30 e0       	ldi	r19, 0x00	; 0

void binary_to_ascii(const char *bin, unsigned char *value)
{
	int last =  strlen(bin);
	*value = 0;
	int tem  = SCHAR_MAX +1 ;//128
     ca6:	40 e8       	ldi	r20, 0x80	; 128
     ca8:	50 e0       	ldi	r21, 0x00	; 0
	for(  int i= 0 ; i< last; i++)
	{
		if( *(bin+i) == '1')
     caa:	81 91       	ld	r24, Z+
     cac:	81 33       	cpi	r24, 0x31	; 49
     cae:	19 f4       	brne	.+6      	; 0xcb6 <binary_to_ascii+0x32>
		{
			*value = *value + tem;
     cb0:	88 81       	ld	r24, Y
     cb2:	84 0f       	add	r24, r20
     cb4:	88 83       	st	Y, r24
		}
		tem=tem>>1;
     cb6:	55 95       	asr	r21
     cb8:	47 95       	ror	r20
void binary_to_ascii(const char *bin, unsigned char *value)
{
	int last =  strlen(bin);
	*value = 0;
	int tem  = SCHAR_MAX +1 ;//128
	for(  int i= 0 ; i< last; i++)
     cba:	2f 5f       	subi	r18, 0xFF	; 255
     cbc:	3f 4f       	sbci	r19, 0xFF	; 255
     cbe:	a2 17       	cp	r26, r18
     cc0:	b3 07       	cpc	r27, r19
     cc2:	99 f7       	brne	.-26     	; 0xcaa <binary_to_ascii+0x26>
		{
			*value = *value + tem;
		}
		tem=tem>>1;
	}
}
     cc4:	df 91       	pop	r29
     cc6:	cf 91       	pop	r28
     cc8:	08 95       	ret

00000cca <hex_to_ascii>:

void hex_to_ascii(const char *hex, unsigned char *chr)
{
     cca:	bf 92       	push	r11
     ccc:	cf 92       	push	r12
     cce:	df 92       	push	r13
     cd0:	ef 92       	push	r14
     cd2:	ff 92       	push	r15
     cd4:	0f 93       	push	r16
     cd6:	1f 93       	push	r17
     cd8:	cf 93       	push	r28
     cda:	df 93       	push	r29
     cdc:	cd b7       	in	r28, 0x3d	; 61
     cde:	de b7       	in	r29, 0x3e	; 62
     ce0:	63 97       	sbiw	r28, 0x13	; 19
     ce2:	0f b6       	in	r0, 0x3f	; 63
     ce4:	f8 94       	cli
     ce6:	de bf       	out	0x3e, r29	; 62
     ce8:	0f be       	out	0x3f, r0	; 63
     cea:	cd bf       	out	0x3d, r28	; 61
     cec:	fc 01       	movw	r30, r24
     cee:	6b 01       	movw	r12, r22
	char binary[9] = {0};
     cf0:	9e 01       	movw	r18, r28
     cf2:	2f 5f       	subi	r18, 0xFF	; 255
     cf4:	3f 4f       	sbci	r19, 0xFF	; 255
     cf6:	89 e0       	ldi	r24, 0x09	; 9
     cf8:	d9 01       	movw	r26, r18
     cfa:	1d 92       	st	X+, r1
     cfc:	8a 95       	dec	r24
     cfe:	e9 f7       	brne	.-6      	; 0xcfa <hex_to_ascii+0x30>
	char firstbinary[5] = {0};
     d00:	85 e0       	ldi	r24, 0x05	; 5
     d02:	27 5f       	subi	r18, 0xF7	; 247
     d04:	3f 4f       	sbci	r19, 0xFF	; 255
     d06:	d9 01       	movw	r26, r18
     d08:	98 2f       	mov	r25, r24
     d0a:	1d 92       	st	X+, r1
     d0c:	9a 95       	dec	r25
     d0e:	e9 f7       	brne	.-6      	; 0xd0a <hex_to_ascii+0x40>
	char lastbinary[5] = {0};
     d10:	2b 5f       	subi	r18, 0xFB	; 251
     d12:	3f 4f       	sbci	r19, 0xFF	; 255
     d14:	d9 01       	movw	r26, r18
     d16:	1d 92       	st	X+, r1
     d18:	8a 95       	dec	r24
     d1a:	e9 f7       	brne	.-6      	; 0xd16 <hex_to_ascii+0x4c>
	char firtHex;
	char lastHex;

	if ( (hex+0 == '\0') || (hex+1 == '\0'))
     d1c:	30 97       	sbiw	r30, 0x00	; 0
     d1e:	59 f1       	breq	.+86     	; 0xd76 <hex_to_ascii+0xac>
     d20:	ef 3f       	cpi	r30, 0xFF	; 255
     d22:	bf ef       	ldi	r27, 0xFF	; 255
     d24:	fb 07       	cpc	r31, r27
     d26:	39 f1       	breq	.+78     	; 0xd76 <hex_to_ascii+0xac>
	{
		return;
	}

	firtHex = *(hex+0);
	lastHex = *(hex+1);
     d28:	b1 80       	ldd	r11, Z+1	; 0x01

	hex_to_binary(firtHex,firstbinary );
     d2a:	8e 01       	movw	r16, r28
     d2c:	06 5f       	subi	r16, 0xF6	; 246
     d2e:	1f 4f       	sbci	r17, 0xFF	; 255
     d30:	b8 01       	movw	r22, r16
     d32:	80 81       	ld	r24, Z
     d34:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <hex_to_binary>
	hex_to_binary(lastHex,lastbinary );
     d38:	7e 01       	movw	r14, r28
     d3a:	8f e0       	ldi	r24, 0x0F	; 15
     d3c:	e8 0e       	add	r14, r24
     d3e:	f1 1c       	adc	r15, r1
     d40:	b7 01       	movw	r22, r14
     d42:	8b 2d       	mov	r24, r11
     d44:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <hex_to_binary>

	sprintf(binary,"%s%s", firstbinary,lastbinary);
     d48:	ff 92       	push	r15
     d4a:	ef 92       	push	r14
     d4c:	1f 93       	push	r17
     d4e:	0f 93       	push	r16
     d50:	86 ee       	ldi	r24, 0xE6	; 230
     d52:	91 e0       	ldi	r25, 0x01	; 1
     d54:	9f 93       	push	r25
     d56:	8f 93       	push	r24
     d58:	09 50       	subi	r16, 0x09	; 9
     d5a:	11 09       	sbc	r17, r1
     d5c:	1f 93       	push	r17
     d5e:	0f 93       	push	r16
     d60:	0e 94 b4 0b 	call	0x1768	; 0x1768 <sprintf>
	binary_to_ascii(binary,chr);
     d64:	b6 01       	movw	r22, r12
     d66:	c8 01       	movw	r24, r16
     d68:	0e 94 42 06 	call	0xc84	; 0xc84 <binary_to_ascii>
     d6c:	0f b6       	in	r0, 0x3f	; 63
     d6e:	f8 94       	cli
     d70:	de bf       	out	0x3e, r29	; 62
     d72:	0f be       	out	0x3f, r0	; 63
     d74:	cd bf       	out	0x3d, r28	; 61
}
     d76:	63 96       	adiw	r28, 0x13	; 19
     d78:	0f b6       	in	r0, 0x3f	; 63
     d7a:	f8 94       	cli
     d7c:	de bf       	out	0x3e, r29	; 62
     d7e:	0f be       	out	0x3f, r0	; 63
     d80:	cd bf       	out	0x3d, r28	; 61
     d82:	df 91       	pop	r29
     d84:	cf 91       	pop	r28
     d86:	1f 91       	pop	r17
     d88:	0f 91       	pop	r16
     d8a:	ff 90       	pop	r15
     d8c:	ef 90       	pop	r14
     d8e:	df 90       	pop	r13
     d90:	cf 90       	pop	r12
     d92:	bf 90       	pop	r11
     d94:	08 95       	ret

00000d96 <hex_to_string>:

void hex_to_string(const char *hex,unsigned char *chr)
{
     d96:	af 92       	push	r10
     d98:	bf 92       	push	r11
     d9a:	cf 92       	push	r12
     d9c:	df 92       	push	r13
     d9e:	ef 92       	push	r14
     da0:	ff 92       	push	r15
     da2:	0f 93       	push	r16
     da4:	1f 93       	push	r17
     da6:	cf 93       	push	r28
     da8:	df 93       	push	r29
     daa:	00 d0       	rcall	.+0      	; 0xdac <hex_to_string+0x16>
     dac:	00 d0       	rcall	.+0      	; 0xdae <hex_to_string+0x18>
     dae:	cd b7       	in	r28, 0x3d	; 61
     db0:	de b7       	in	r29, 0x3e	; 62
     db2:	6b 01       	movw	r12, r22
	unsigned int ilen = strlen(hex);
     db4:	fc 01       	movw	r30, r24
     db6:	01 90       	ld	r0, Z+
     db8:	00 20       	and	r0, r0
     dba:	e9 f7       	brne	.-6      	; 0xdb6 <hex_to_string+0x20>
     dbc:	31 97       	sbiw	r30, 0x01	; 1
     dbe:	5f 01       	movw	r10, r30
     dc0:	a8 1a       	sub	r10, r24
     dc2:	b9 0a       	sbc	r11, r25
	for (unsigned int i = 0 ; i < ilen ; i= i+2)
     dc4:	29 f1       	breq	.+74     	; 0xe10 <hex_to_string+0x7a>
     dc6:	8c 01       	movw	r16, r24
     dc8:	0f 5f       	subi	r16, 0xFF	; 255
     dca:	1f 4f       	sbci	r17, 0xFF	; 255
     dcc:	e1 2c       	mov	r14, r1
     dce:	f1 2c       	mov	r15, r1
	{
		unsigned char buffer[3] = {0};
     dd0:	19 82       	std	Y+1, r1	; 0x01
     dd2:	1a 82       	std	Y+2, r1	; 0x02
     dd4:	1b 82       	std	Y+3, r1	; 0x03
     dd6:	f8 01       	movw	r30, r16
     dd8:	31 97       	sbiw	r30, 0x01	; 1
		unsigned char temp ;

		buffer[0] = hex[i];
     dda:	80 81       	ld	r24, Z
     ddc:	89 83       	std	Y+1, r24	; 0x01
		buffer[1] = hex[i+1];
     dde:	f8 01       	movw	r30, r16
     de0:	80 81       	ld	r24, Z
     de2:	8a 83       	std	Y+2, r24	; 0x02
		hex_to_ascii((const char *)buffer,&temp);
     de4:	be 01       	movw	r22, r28
     de6:	6c 5f       	subi	r22, 0xFC	; 252
     de8:	7f 4f       	sbci	r23, 0xFF	; 255
     dea:	ce 01       	movw	r24, r28
     dec:	01 96       	adiw	r24, 0x01	; 1
     dee:	0e 94 65 06 	call	0xcca	; 0xcca <hex_to_ascii>
		if(chr != '\0')
     df2:	c1 14       	cp	r12, r1
     df4:	d1 04       	cpc	r13, r1
     df6:	21 f0       	breq	.+8      	; 0xe00 <hex_to_string+0x6a>
		{
			*chr = temp;
     df8:	8c 81       	ldd	r24, Y+4	; 0x04
     dfa:	f6 01       	movw	r30, r12
     dfc:	81 93       	st	Z+, r24
     dfe:	6f 01       	movw	r12, r30
}

void hex_to_string(const char *hex,unsigned char *chr)
{
	unsigned int ilen = strlen(hex);
	for (unsigned int i = 0 ; i < ilen ; i= i+2)
     e00:	f2 e0       	ldi	r31, 0x02	; 2
     e02:	ef 0e       	add	r14, r31
     e04:	f1 1c       	adc	r15, r1
     e06:	0e 5f       	subi	r16, 0xFE	; 254
     e08:	1f 4f       	sbci	r17, 0xFF	; 255
     e0a:	ea 14       	cp	r14, r10
     e0c:	fb 04       	cpc	r15, r11
     e0e:	00 f3       	brcs	.-64     	; 0xdd0 <hex_to_string+0x3a>
		{
			*chr = temp;
			chr++;
		}
	}
}
     e10:	0f 90       	pop	r0
     e12:	0f 90       	pop	r0
     e14:	0f 90       	pop	r0
     e16:	0f 90       	pop	r0
     e18:	df 91       	pop	r29
     e1a:	cf 91       	pop	r28
     e1c:	1f 91       	pop	r17
     e1e:	0f 91       	pop	r16
     e20:	ff 90       	pop	r15
     e22:	ef 90       	pop	r14
     e24:	df 90       	pop	r13
     e26:	cf 90       	pop	r12
     e28:	bf 90       	pop	r11
     e2a:	af 90       	pop	r10
     e2c:	08 95       	ret

00000e2e <check_sum>:
		break;
	}
}

void check_sum(const unsigned char *ptr,unsigned int length, unsigned char *checksum)
{
     e2e:	da 01       	movw	r26, r20
	*checksum = '\0';
     e30:	1c 92       	st	X, r1
	for (unsigned int i = 0; i< length ; i++)
     e32:	61 15       	cp	r22, r1
     e34:	71 05       	cpc	r23, r1
     e36:	51 f0       	breq	.+20     	; 0xe4c <check_sum+0x1e>
     e38:	fc 01       	movw	r30, r24
     e3a:	86 0f       	add	r24, r22
     e3c:	97 1f       	adc	r25, r23
	{
		*checksum =*checksum + ptr[i];
     e3e:	21 91       	ld	r18, Z+
     e40:	3c 91       	ld	r19, X
     e42:	23 0f       	add	r18, r19
     e44:	2c 93       	st	X, r18
}

void check_sum(const unsigned char *ptr,unsigned int length, unsigned char *checksum)
{
	*checksum = '\0';
	for (unsigned int i = 0; i< length ; i++)
     e46:	e8 17       	cp	r30, r24
     e48:	f9 07       	cpc	r31, r25
     e4a:	c9 f7       	brne	.-14     	; 0xe3e <check_sum+0x10>
     e4c:	08 95       	ret

00000e4e <equal2strbytes>:
}

int equal2strbytes(const  char *ptr1 ,const char *ptr2, unsigned int length)
{
	
	for (unsigned int i = 0; i< length; i++)
     e4e:	41 15       	cp	r20, r1
     e50:	51 05       	cpc	r21, r1
     e52:	b9 f0       	breq	.+46     	; 0xe82 <equal2strbytes+0x34>
	{
		if(*ptr1  != *ptr2)
     e54:	fc 01       	movw	r30, r24
     e56:	30 81       	ld	r19, Z
     e58:	fb 01       	movw	r30, r22
     e5a:	20 81       	ld	r18, Z
     e5c:	32 13       	cpse	r19, r18
     e5e:	14 c0       	rjmp	.+40     	; 0xe88 <equal2strbytes+0x3a>
     e60:	fc 01       	movw	r30, r24
     e62:	31 96       	adiw	r30, 0x01	; 1
     e64:	db 01       	movw	r26, r22
     e66:	11 96       	adiw	r26, 0x01	; 1
     e68:	48 0f       	add	r20, r24
     e6a:	59 1f       	adc	r21, r25
     e6c:	04 c0       	rjmp	.+8      	; 0xe76 <equal2strbytes+0x28>
     e6e:	91 91       	ld	r25, Z+
     e70:	8d 91       	ld	r24, X+
     e72:	98 13       	cpse	r25, r24
     e74:	0c c0       	rjmp	.+24     	; 0xe8e <equal2strbytes+0x40>
}

int equal2strbytes(const  char *ptr1 ,const char *ptr2, unsigned int length)
{
	
	for (unsigned int i = 0; i< length; i++)
     e76:	e4 17       	cp	r30, r20
     e78:	f5 07       	cpc	r31, r21
     e7a:	c9 f7       	brne	.-14     	; 0xe6e <equal2strbytes+0x20>
			return -1;
		}
		ptr1++;
		ptr2++;
	}
	return 0;
     e7c:	80 e0       	ldi	r24, 0x00	; 0
     e7e:	90 e0       	ldi	r25, 0x00	; 0
     e80:	08 95       	ret
     e82:	80 e0       	ldi	r24, 0x00	; 0
     e84:	90 e0       	ldi	r25, 0x00	; 0
     e86:	08 95       	ret
	
	for (unsigned int i = 0; i< length; i++)
	{
		if(*ptr1  != *ptr2)
		{
			return -1;
     e88:	8f ef       	ldi	r24, 0xFF	; 255
     e8a:	9f ef       	ldi	r25, 0xFF	; 255
     e8c:	08 95       	ret
     e8e:	8f ef       	ldi	r24, 0xFF	; 255
     e90:	9f ef       	ldi	r25, 0xFF	; 255
		}
		ptr1++;
		ptr2++;
	}
	return 0;
}
     e92:	08 95       	ret

00000e94 <equal2strUnsignedChars>:

int equal2strUnsignedChars(const unsigned char *ptr1 ,const unsigned char *ptr2, unsigned int length)
{
	for (unsigned int i = 0; i< length; i++)
     e94:	41 15       	cp	r20, r1
     e96:	51 05       	cpc	r21, r1
     e98:	b9 f0       	breq	.+46     	; 0xec8 <equal2strUnsignedChars+0x34>
	{
		if(*ptr1  != *ptr2)
     e9a:	fc 01       	movw	r30, r24
     e9c:	30 81       	ld	r19, Z
     e9e:	fb 01       	movw	r30, r22
     ea0:	20 81       	ld	r18, Z
     ea2:	32 13       	cpse	r19, r18
     ea4:	14 c0       	rjmp	.+40     	; 0xece <equal2strUnsignedChars+0x3a>
     ea6:	fc 01       	movw	r30, r24
     ea8:	31 96       	adiw	r30, 0x01	; 1
     eaa:	db 01       	movw	r26, r22
     eac:	11 96       	adiw	r26, 0x01	; 1
     eae:	48 0f       	add	r20, r24
     eb0:	59 1f       	adc	r21, r25
     eb2:	04 c0       	rjmp	.+8      	; 0xebc <equal2strUnsignedChars+0x28>
     eb4:	91 91       	ld	r25, Z+
     eb6:	8d 91       	ld	r24, X+
     eb8:	98 13       	cpse	r25, r24
     eba:	0c c0       	rjmp	.+24     	; 0xed4 <equal2strUnsignedChars+0x40>
	return 0;
}

int equal2strUnsignedChars(const unsigned char *ptr1 ,const unsigned char *ptr2, unsigned int length)
{
	for (unsigned int i = 0; i< length; i++)
     ebc:	e4 17       	cp	r30, r20
     ebe:	f5 07       	cpc	r31, r21
     ec0:	c9 f7       	brne	.-14     	; 0xeb4 <equal2strUnsignedChars+0x20>
			return -1;
		}
		ptr1++;
		ptr2++;
	}
	return 0;
     ec2:	80 e0       	ldi	r24, 0x00	; 0
     ec4:	90 e0       	ldi	r25, 0x00	; 0
     ec6:	08 95       	ret
     ec8:	80 e0       	ldi	r24, 0x00	; 0
     eca:	90 e0       	ldi	r25, 0x00	; 0
     ecc:	08 95       	ret
{
	for (unsigned int i = 0; i< length; i++)
	{
		if(*ptr1  != *ptr2)
		{
			return -1;
     ece:	8f ef       	ldi	r24, 0xFF	; 255
     ed0:	9f ef       	ldi	r25, 0xFF	; 255
     ed2:	08 95       	ret
     ed4:	8f ef       	ldi	r24, 0xFF	; 255
     ed6:	9f ef       	ldi	r25, 0xFF	; 255
		}
		ptr1++;
		ptr2++;
	}
	return 0;
     ed8:	08 95       	ret

00000eda <Zigbee_init>:
IR_FORMAT g_ir_formal;


void Zigbee_init()
{
    gZigbeeInfo.PanId         = '\0';
     eda:	10 92 4c 02 	sts	0x024C, r1
     ede:	10 92 4b 02 	sts	0x024B, r1
    gZigbeeInfo.ShortAddresss = '\0';
     ee2:	10 92 4e 02 	sts	0x024E, r1
     ee6:	10 92 4d 02 	sts	0x024D, r1
    gZigbeeInfo.MacAddress    = '\0';
     eea:	10 92 50 02 	sts	0x0250, r1
     eee:	10 92 4f 02 	sts	0x024F, r1
    gZigbeeInfo.PointType     = '\0';
     ef2:	10 92 52 02 	sts	0x0252, r1
     ef6:	10 92 51 02 	sts	0x0251, r1
    gZigbeeInfo.RadioChanel   = '\0';
     efa:	10 92 54 02 	sts	0x0254, r1
     efe:	10 92 53 02 	sts	0x0253, r1
     f02:	08 95       	ret

00000f04 <verifyPanID>:
{
    return 0;
}

int verifyPanID()
{
     f04:	0f 93       	push	r16
     f06:	1f 93       	push	r17
     f08:	cf 93       	push	r28
     f0a:	df 93       	push	r29
     f0c:	00 d0       	rcall	.+0      	; 0xf0e <verifyPanID+0xa>
     f0e:	00 d0       	rcall	.+0      	; 0xf10 <verifyPanID+0xc>
     f10:	1f 92       	push	r1
     f12:	cd b7       	in	r28, 0x3d	; 61
     f14:	de b7       	in	r29, 0x3e	; 62
    char hex[5] = {0};
     f16:	8e 01       	movw	r16, r28
     f18:	0f 5f       	subi	r16, 0xFF	; 255
     f1a:	1f 4f       	sbci	r17, 0xFF	; 255
     f1c:	85 e0       	ldi	r24, 0x05	; 5
     f1e:	f8 01       	movw	r30, r16
     f20:	11 92       	st	Z+, r1
     f22:	8a 95       	dec	r24
     f24:	e9 f7       	brne	.-6      	; 0xf20 <verifyPanID+0x1c>
    string_to_hex(gZigbeeInfo.PanId,2, hex);
     f26:	a8 01       	movw	r20, r16
     f28:	62 e0       	ldi	r22, 0x02	; 2
     f2a:	70 e0       	ldi	r23, 0x00	; 0
     f2c:	80 91 4b 02 	lds	r24, 0x024B
     f30:	90 91 4c 02 	lds	r25, 0x024C
     f34:	0e 94 0c 06 	call	0xc18	; 0xc18 <string_to_hex>

    if (equal2strbytes(hex,ZIGBEE_RETURN_PAN_ID, 4) == 0)
     f38:	44 e0       	ldi	r20, 0x04	; 4
     f3a:	50 e0       	ldi	r21, 0x00	; 0
     f3c:	6b ee       	ldi	r22, 0xEB	; 235
     f3e:	71 e0       	ldi	r23, 0x01	; 1
     f40:	c8 01       	movw	r24, r16
     f42:	0e 94 27 07 	call	0xe4e	; 0xe4e <equal2strbytes>
     f46:	21 e0       	ldi	r18, 0x01	; 1
     f48:	30 e0       	ldi	r19, 0x00	; 0
     f4a:	89 2b       	or	r24, r25
     f4c:	11 f4       	brne	.+4      	; 0xf52 <verifyPanID+0x4e>
     f4e:	20 e0       	ldi	r18, 0x00	; 0
     f50:	30 e0       	ldi	r19, 0x00	; 0
    {
        return 0;
    }

    return -1;
}
     f52:	88 27       	eor	r24, r24
     f54:	99 27       	eor	r25, r25
     f56:	82 1b       	sub	r24, r18
     f58:	93 0b       	sbc	r25, r19
     f5a:	0f 90       	pop	r0
     f5c:	0f 90       	pop	r0
     f5e:	0f 90       	pop	r0
     f60:	0f 90       	pop	r0
     f62:	0f 90       	pop	r0
     f64:	df 91       	pop	r29
     f66:	cf 91       	pop	r28
     f68:	1f 91       	pop	r17
     f6a:	0f 91       	pop	r16
     f6c:	08 95       	ret

00000f6e <RequestCommand>:
{
    return 0;
}

void RequestCommand(const char *ptrZchRequest, unsigned char **ptrResponse, unsigned int length , unsigned int *byte_read)
{
     f6e:	af 92       	push	r10
     f70:	bf 92       	push	r11
     f72:	cf 92       	push	r12
     f74:	df 92       	push	r13
     f76:	ef 92       	push	r14
     f78:	ff 92       	push	r15
     f7a:	0f 93       	push	r16
     f7c:	1f 93       	push	r17
     f7e:	cf 93       	push	r28
     f80:	df 93       	push	r29
     f82:	cd b7       	in	r28, 0x3d	; 61
     f84:	de b7       	in	r29, 0x3e	; 62
     f86:	29 97       	sbiw	r28, 0x09	; 9
     f88:	0f b6       	in	r0, 0x3f	; 63
     f8a:	f8 94       	cli
     f8c:	de bf       	out	0x3e, r29	; 62
     f8e:	0f be       	out	0x3f, r0	; 63
     f90:	cd bf       	out	0x3d, r28	; 61
     f92:	6b 01       	movw	r12, r22
     f94:	5a 01       	movw	r10, r20
     f96:	79 01       	movw	r14, r18
    unsigned char command[8] = {0};
     f98:	8e 01       	movw	r16, r28
     f9a:	0f 5f       	subi	r16, 0xFF	; 255
     f9c:	1f 4f       	sbci	r17, 0xFF	; 255
     f9e:	28 e0       	ldi	r18, 0x08	; 8
     fa0:	f8 01       	movw	r30, r16
     fa2:	11 92       	st	Z+, r1
     fa4:	2a 95       	dec	r18
     fa6:	e9 f7       	brne	.-6      	; 0xfa2 <RequestCommand+0x34>
    unsigned char checksum;

    hex_to_string(ptrZchRequest,command);
     fa8:	b8 01       	movw	r22, r16
     faa:	0e 94 cb 06 	call	0xd96	; 0xd96 <hex_to_string>
    check_sum(command,6, &checksum);
     fae:	ae 01       	movw	r20, r28
     fb0:	47 5f       	subi	r20, 0xF7	; 247
     fb2:	5f 4f       	sbci	r21, 0xFF	; 255
     fb4:	66 e0       	ldi	r22, 0x06	; 6
     fb6:	70 e0       	ldi	r23, 0x00	; 0
     fb8:	c8 01       	movw	r24, r16
     fba:	0e 94 17 07 	call	0xe2e	; 0xe2e <check_sum>
    /*Add check sum */
    command[6] = checksum;
     fbe:	89 85       	ldd	r24, Y+9	; 0x09
     fc0:	8f 83       	std	Y+7, r24	; 0x07
    /*make sure that the end of string*/
    command[7] = '\0';
     fc2:	18 86       	std	Y+8, r1	; 0x08
    USART_Transmits(command,7);
     fc4:	67 e0       	ldi	r22, 0x07	; 7
     fc6:	70 e0       	ldi	r23, 0x00	; 0
     fc8:	c8 01       	movw	r24, r16
     fca:	0e 94 60 09 	call	0x12c0	; 0x12c0 <USART_Transmits>
    *ptrResponse = USART_Receives(length,byte_read);
     fce:	b7 01       	movw	r22, r14
     fd0:	c5 01       	movw	r24, r10
     fd2:	0e 94 9c 09 	call	0x1338	; 0x1338 <USART_Receives>
     fd6:	f6 01       	movw	r30, r12
     fd8:	91 83       	std	Z+1, r25	; 0x01
     fda:	80 83       	st	Z, r24
}
     fdc:	29 96       	adiw	r28, 0x09	; 9
     fde:	0f b6       	in	r0, 0x3f	; 63
     fe0:	f8 94       	cli
     fe2:	de bf       	out	0x3e, r29	; 62
     fe4:	0f be       	out	0x3f, r0	; 63
     fe6:	cd bf       	out	0x3d, r28	; 61
     fe8:	df 91       	pop	r29
     fea:	cf 91       	pop	r28
     fec:	1f 91       	pop	r17
     fee:	0f 91       	pop	r16
     ff0:	ff 90       	pop	r15
     ff2:	ef 90       	pop	r14
     ff4:	df 90       	pop	r13
     ff6:	cf 90       	pop	r12
     ff8:	bf 90       	pop	r11
     ffa:	af 90       	pop	r10
     ffc:	08 95       	ret

00000ffe <ZigBee_get_Config>:
    gZigbeeInfo.MacAddress    = '\0';
    gZigbeeInfo.PointType     = '\0';
    gZigbeeInfo.RadioChanel   = '\0';
}
void ZigBee_get_Config()
{
     ffe:	cf 93       	push	r28
    1000:	df 93       	push	r29
    1002:	00 d0       	rcall	.+0      	; 0x1004 <ZigBee_get_Config+0x6>
    1004:	cd b7       	in	r28, 0x3d	; 61
    1006:	de b7       	in	r29, 0x3e	; 62
    unsigned int byte_read = 0;
    1008:	1a 82       	std	Y+2, r1	; 0x02
    100a:	19 82       	std	Y+1, r1	; 0x01
    RequestCommand( ZIGBEE_READ_PAN_ID, &gZigbeeInfo.PanId, 2, &byte_read);
    100c:	9e 01       	movw	r18, r28
    100e:	2f 5f       	subi	r18, 0xFF	; 255
    1010:	3f 4f       	sbci	r19, 0xFF	; 255
    1012:	42 e0       	ldi	r20, 0x02	; 2
    1014:	50 e0       	ldi	r21, 0x00	; 0
    1016:	6b e4       	ldi	r22, 0x4B	; 75
    1018:	72 e0       	ldi	r23, 0x02	; 2
    101a:	80 ef       	ldi	r24, 0xF0	; 240
    101c:	91 e0       	ldi	r25, 0x01	; 1
    101e:	0e 94 b7 07 	call	0xf6e	; 0xf6e <RequestCommand>
}
    1022:	0f 90       	pop	r0
    1024:	0f 90       	pop	r0
    1026:	df 91       	pop	r29
    1028:	cf 91       	pop	r28
    102a:	08 95       	ret

0000102c <Zigbee_receive_data>:
    USART_Transmits(command,7);
    *ptrResponse = USART_Receives(length,byte_read);
}

void Zigbee_receive_data()
{
    102c:	cf 92       	push	r12
    102e:	df 92       	push	r13
    1030:	ef 92       	push	r14
    1032:	ff 92       	push	r15
    1034:	0f 93       	push	r16
    1036:	1f 93       	push	r17
    1038:	cf 93       	push	r28
    103a:	df 93       	push	r29
    103c:	00 d0       	rcall	.+0      	; 0x103e <Zigbee_receive_data+0x12>
    103e:	1f 92       	push	r1
    1040:	cd b7       	in	r28, 0x3d	; 61
    1042:	de b7       	in	r29, 0x3e	; 62
    * if chr_pre_data = F -> remote control IR
    * if
    */
    while(1)
    {
        iRet = USART_Receive(&chr_pre_data);
    1044:	ce 01       	movw	r24, r28
    1046:	01 96       	adiw	r24, 0x01	; 1
    1048:	0e 94 85 09 	call	0x130a	; 0x130a <USART_Receive>

        /*
        *start bit : 0XF0
        */
        if (iRet == 0 && chr_pre_data == 0xF0)
    104c:	89 2b       	or	r24, r25
    104e:	d1 f7       	brne	.-12     	; 0x1044 <Zigbee_receive_data+0x18>
    1050:	89 81       	ldd	r24, Y+1	; 0x01
    1052:	80 3f       	cpi	r24, 0xF0	; 240
    1054:	b9 f7       	brne	.-18     	; 0x1044 <Zigbee_receive_data+0x18>
    }//End while()

    /*
    *get length of data 0XFF,etc.
    */
    iRet = USART_Receive(&chr_pre_data);
    1056:	ce 01       	movw	r24, r28
    1058:	01 96       	adiw	r24, 0x01	; 1
    105a:	0e 94 85 09 	call	0x130a	; 0x130a <USART_Receive>
    if (iRet != 0)
    105e:	89 2b       	or	r24, r25
    1060:	09 f0       	breq	.+2      	; 0x1064 <Zigbee_receive_data+0x38>
    1062:	02 c1       	rjmp	.+516    	; 0x1268 <Zigbee_receive_data+0x23c>
    {
        return;
    }

    unsigned int length = chr_pre_data;
    1064:	e9 80       	ldd	r14, Y+1	; 0x01
    1066:	f1 2c       	mov	r15, r1
    unsigned int byte_read =0;
    1068:	1b 82       	std	Y+3, r1	; 0x03
    106a:	1a 82       	std	Y+2, r1	; 0x02
    unsigned char *ptr =  USART_Receives(length,&byte_read);
    106c:	be 01       	movw	r22, r28
    106e:	6e 5f       	subi	r22, 0xFE	; 254
    1070:	7f 4f       	sbci	r23, 0xFF	; 255
    1072:	c7 01       	movw	r24, r14
    1074:	0e 94 9c 09 	call	0x1338	; 0x1338 <USART_Receives>
    1078:	8c 01       	movw	r16, r24

    if(*ptr == IR_TYPE_COMMNAD)
    107a:	fc 01       	movw	r30, r24
    107c:	80 81       	ld	r24, Z
    107e:	80 3f       	cpi	r24, 0xF0	; 240
    1080:	09 f5       	brne	.+66     	; 0x10c4 <Zigbee_receive_data+0x98>
    {
        char *ptr_hexs = (char *)malloc( (length-1)*2+1);
    1082:	c7 01       	movw	r24, r14
    1084:	88 0f       	add	r24, r24
    1086:	99 1f       	adc	r25, r25
    1088:	01 97       	sbiw	r24, 0x01	; 1
    108a:	0e 94 8d 0a 	call	0x151a	; 0x151a <malloc>
    108e:	6c 01       	movw	r12, r24
        if (ptr_hexs == '\0')
    1090:	00 97       	sbiw	r24, 0x00	; 0
    1092:	09 f4       	brne	.+2      	; 0x1096 <Zigbee_receive_data+0x6a>
    1094:	e9 c0       	rjmp	.+466    	; 0x1268 <Zigbee_receive_data+0x23c>
        {
            return;
        }
        string_to_hex((ptr+1), (length-1),ptr_hexs);
    1096:	b7 01       	movw	r22, r14
    1098:	61 50       	subi	r22, 0x01	; 1
    109a:	71 09       	sbc	r23, r1
    109c:	ac 01       	movw	r20, r24
    109e:	c8 01       	movw	r24, r16
    10a0:	01 96       	adiw	r24, 0x01	; 1
    10a2:	0e 94 0c 06 	call	0xc18	; 0xc18 <string_to_hex>
        IR_send((unsigned char *) ptr_hexs,8);
    10a6:	68 e0       	ldi	r22, 0x08	; 8
    10a8:	70 e0       	ldi	r23, 0x00	; 0
    10aa:	c6 01       	movw	r24, r12
    10ac:	0e 94 e9 01 	call	0x3d2	; 0x3d2 <IR_send>
        USART_Transmits("OK",2);
    10b0:	62 e0       	ldi	r22, 0x02	; 2
    10b2:	70 e0       	ldi	r23, 0x00	; 0
    10b4:	8d ef       	ldi	r24, 0xFD	; 253
    10b6:	91 e0       	ldi	r25, 0x01	; 1
    10b8:	0e 94 60 09 	call	0x12c0	; 0x12c0 <USART_Transmits>
        /*Release memory*/
        free(ptr_hexs);
    10bc:	c6 01       	movw	r24, r12
    10be:	0e 94 25 0b 	call	0x164a	; 0x164a <free>
    10c2:	cc c0       	rjmp	.+408    	; 0x125c <Zigbee_receive_data+0x230>
    }
    else if(*ptr == IR_TYPE_CONGIGURATION)
    10c4:	81 3f       	cpi	r24, 0xF1	; 241
    10c6:	09 f0       	breq	.+2      	; 0x10ca <Zigbee_receive_data+0x9e>
    10c8:	a8 c0       	rjmp	.+336    	; 0x121a <Zigbee_receive_data+0x1ee>

        //F0 19 F1 F0 94 70 F1 03 E8 F2 01 BE F3 01 CE F4 00 37 F5 00 A6 F6 00 38 F7 00 20
        //      0 -1  2  3 -4  5  6 -7  8  9 -10 11 12-13 14 15-16 17 18-19 20 21-22 23 24
        unsigned int iValue = 0;

        if (*(ptr+1) == IR_CONFIGURATION_CARRIER_FREQUENCY)
    10ca:	f8 01       	movw	r30, r16
    10cc:	81 81       	ldd	r24, Z+1	; 0x01
    10ce:	80 3f       	cpi	r24, 0xF0	; 240
    10d0:	b9 f4       	brne	.+46     	; 0x1100 <Zigbee_receive_data+0xd4>
        {
            iValue = 0;
            iValue = (unsigned int) *(ptr+2);
    10d2:	e2 80       	ldd	r14, Z+2	; 0x02
    10d4:	f1 2c       	mov	r15, r1
            iValue = iValue <<8;
    10d6:	fe 2c       	mov	r15, r14
    10d8:	ee 24       	eor	r14, r14
            iValue = iValue  +  (unsigned int) *(ptr+3);
    10da:	83 81       	ldd	r24, Z+3	; 0x03
    10dc:	e8 0e       	add	r14, r24
    10de:	f1 1c       	adc	r15, r1
            eeprom_update_word(( uint16_t *) IR_CONFIGURATION_ADD_CARRIER_FREQUENCY, iValue);
    10e0:	b7 01       	movw	r22, r14
    10e2:	80 e0       	ldi	r24, 0x00	; 0
    10e4:	90 e0       	ldi	r25, 0x00	; 0
    10e6:	0e 94 c8 0d 	call	0x1b90	; 0x1b90 <__eeupd_word_m328>
            g_ir_formal.carrier_frequency = iValue;
    10ea:	a7 01       	movw	r20, r14
    10ec:	60 e0       	ldi	r22, 0x00	; 0
    10ee:	70 e0       	ldi	r23, 0x00	; 0
    10f0:	40 93 01 02 	sts	0x0201, r20
    10f4:	50 93 02 02 	sts	0x0202, r21
    10f8:	60 93 03 02 	sts	0x0203, r22
    10fc:	70 93 04 02 	sts	0x0204, r23
        }

        if(*(ptr+4) == IR_CONFIGURATION_START_COMMAND)
    1100:	f8 01       	movw	r30, r16
    1102:	84 81       	ldd	r24, Z+4	; 0x04
    1104:	81 3f       	cpi	r24, 0xF1	; 241
    1106:	81 f4       	brne	.+32     	; 0x1128 <Zigbee_receive_data+0xfc>
        {
            iValue = 0;
            iValue = (unsigned int) *(ptr+5);
    1108:	e5 80       	ldd	r14, Z+5	; 0x05
    110a:	f1 2c       	mov	r15, r1
            iValue = iValue <<8;
    110c:	fe 2c       	mov	r15, r14
    110e:	ee 24       	eor	r14, r14
            iValue = iValue  +  (unsigned int) *(ptr+6);
    1110:	86 81       	ldd	r24, Z+6	; 0x06
    1112:	e8 0e       	add	r14, r24
    1114:	f1 1c       	adc	r15, r1
            eeprom_update_word(( uint16_t *) IR_CONFIGURATION_ADD_START_COMMAND, iValue);
    1116:	b7 01       	movw	r22, r14
    1118:	82 e0       	ldi	r24, 0x02	; 2
    111a:	90 e0       	ldi	r25, 0x00	; 0
    111c:	0e 94 c8 0d 	call	0x1b90	; 0x1b90 <__eeupd_word_m328>
            g_ir_formal.time_start_command = iValue;
    1120:	f0 92 06 02 	sts	0x0206, r15
    1124:	e0 92 05 02 	sts	0x0205, r14
        }

        if (*(ptr+7) == IR_CONFIGURATION_START_MARK)
    1128:	f8 01       	movw	r30, r16
    112a:	87 81       	ldd	r24, Z+7	; 0x07
    112c:	82 3f       	cpi	r24, 0xF2	; 242
    112e:	81 f4       	brne	.+32     	; 0x1150 <Zigbee_receive_data+0x124>
        {
            iValue = 0;
            iValue = (unsigned int) *(ptr+8);
    1130:	e0 84       	ldd	r14, Z+8	; 0x08
    1132:	f1 2c       	mov	r15, r1
            iValue = iValue <<8;
    1134:	fe 2c       	mov	r15, r14
    1136:	ee 24       	eor	r14, r14
            iValue = iValue  +  (unsigned int) *(ptr+9);
    1138:	81 85       	ldd	r24, Z+9	; 0x09
    113a:	e8 0e       	add	r14, r24
    113c:	f1 1c       	adc	r15, r1
            eeprom_update_word(( uint16_t *) IR_CONFIGURATION_ADD_START_MARK, iValue);
    113e:	b7 01       	movw	r22, r14
    1140:	84 e0       	ldi	r24, 0x04	; 4
    1142:	90 e0       	ldi	r25, 0x00	; 0
    1144:	0e 94 c8 0d 	call	0x1b90	; 0x1b90 <__eeupd_word_m328>
            g_ir_formal.time_start_mark = iValue;
    1148:	f0 92 08 02 	sts	0x0208, r15
    114c:	e0 92 07 02 	sts	0x0207, r14
        }

        if (*(ptr+10) == IR_CONFIGURATION_START_SPACE)
    1150:	f8 01       	movw	r30, r16
    1152:	82 85       	ldd	r24, Z+10	; 0x0a
    1154:	83 3f       	cpi	r24, 0xF3	; 243
    1156:	81 f4       	brne	.+32     	; 0x1178 <Zigbee_receive_data+0x14c>
        {
            iValue = 0;
            iValue = (unsigned int) *(ptr+11);
    1158:	e3 84       	ldd	r14, Z+11	; 0x0b
    115a:	f1 2c       	mov	r15, r1
            iValue = iValue <<8;
    115c:	fe 2c       	mov	r15, r14
    115e:	ee 24       	eor	r14, r14
            iValue = iValue  +  (unsigned int) *(ptr+12);
    1160:	84 85       	ldd	r24, Z+12	; 0x0c
    1162:	e8 0e       	add	r14, r24
    1164:	f1 1c       	adc	r15, r1
            eeprom_update_word(( uint16_t *) IR_CONFIGURATION_ADD_START_SPACE, iValue);
    1166:	b7 01       	movw	r22, r14
    1168:	86 e0       	ldi	r24, 0x06	; 6
    116a:	90 e0       	ldi	r25, 0x00	; 0
    116c:	0e 94 c8 0d 	call	0x1b90	; 0x1b90 <__eeupd_word_m328>
            g_ir_formal.time_start_space = iValue;
    1170:	f0 92 0a 02 	sts	0x020A, r15
    1174:	e0 92 09 02 	sts	0x0209, r14
        }

        if (*(ptr+13) == IR_CONFIGURATION_BIT_MARK)
    1178:	f8 01       	movw	r30, r16
    117a:	85 85       	ldd	r24, Z+13	; 0x0d
    117c:	84 3f       	cpi	r24, 0xF4	; 244
    117e:	81 f4       	brne	.+32     	; 0x11a0 <Zigbee_receive_data+0x174>
        {
            iValue = 0;
            iValue = (unsigned int) *(ptr+14);
    1180:	e6 84       	ldd	r14, Z+14	; 0x0e
    1182:	f1 2c       	mov	r15, r1
            iValue = iValue <<8;
    1184:	fe 2c       	mov	r15, r14
    1186:	ee 24       	eor	r14, r14
            iValue = iValue  +  (unsigned int) *(ptr+15);
    1188:	87 85       	ldd	r24, Z+15	; 0x0f
    118a:	e8 0e       	add	r14, r24
    118c:	f1 1c       	adc	r15, r1
            eeprom_update_word(( uint16_t *) IR_CONFIGURATION_ADD_BIT_MARK, iValue);
    118e:	b7 01       	movw	r22, r14
    1190:	88 e0       	ldi	r24, 0x08	; 8
    1192:	90 e0       	ldi	r25, 0x00	; 0
    1194:	0e 94 c8 0d 	call	0x1b90	; 0x1b90 <__eeupd_word_m328>
            g_ir_formal.time_bit_mark= iValue;
    1198:	f0 92 0c 02 	sts	0x020C, r15
    119c:	e0 92 0b 02 	sts	0x020B, r14
        }

        if (*(ptr+16) == IR_CONFIGURATION_BIT_ONE_SPACE)
    11a0:	f8 01       	movw	r30, r16
    11a2:	80 89       	ldd	r24, Z+16	; 0x10
    11a4:	85 3f       	cpi	r24, 0xF5	; 245
    11a6:	81 f4       	brne	.+32     	; 0x11c8 <Zigbee_receive_data+0x19c>
        {
            iValue = 0;
            iValue = (unsigned int) *(ptr+17);
    11a8:	e1 88       	ldd	r14, Z+17	; 0x11
    11aa:	f1 2c       	mov	r15, r1
            iValue = iValue <<8;
    11ac:	fe 2c       	mov	r15, r14
    11ae:	ee 24       	eor	r14, r14
            iValue = iValue  +  (unsigned int) *(ptr+18);
    11b0:	82 89       	ldd	r24, Z+18	; 0x12
    11b2:	e8 0e       	add	r14, r24
    11b4:	f1 1c       	adc	r15, r1
            eeprom_update_word(( uint16_t *) IR_CONFIGURATION_ADD_BIT_ONE_SPACE, iValue);
    11b6:	b7 01       	movw	r22, r14
    11b8:	8a e0       	ldi	r24, 0x0A	; 10
    11ba:	90 e0       	ldi	r25, 0x00	; 0
    11bc:	0e 94 c8 0d 	call	0x1b90	; 0x1b90 <__eeupd_word_m328>
            g_ir_formal.time_one_bit_space= iValue;
    11c0:	f0 92 0e 02 	sts	0x020E, r15
    11c4:	e0 92 0d 02 	sts	0x020D, r14
        }

        if (*(ptr+19) == IR_CONFIGURATION_BIT_ZERO_SPACE)
    11c8:	f8 01       	movw	r30, r16
    11ca:	83 89       	ldd	r24, Z+19	; 0x13
    11cc:	86 3f       	cpi	r24, 0xF6	; 246
    11ce:	81 f4       	brne	.+32     	; 0x11f0 <Zigbee_receive_data+0x1c4>
        {
            iValue = 0;
            iValue = (unsigned int) *(ptr+20);
    11d0:	e4 88       	ldd	r14, Z+20	; 0x14
    11d2:	f1 2c       	mov	r15, r1
            iValue = iValue <<8;
    11d4:	fe 2c       	mov	r15, r14
    11d6:	ee 24       	eor	r14, r14
            iValue = iValue  +  (unsigned int) *(ptr+21);
    11d8:	85 89       	ldd	r24, Z+21	; 0x15
    11da:	e8 0e       	add	r14, r24
    11dc:	f1 1c       	adc	r15, r1
            eeprom_update_word(( uint16_t *) IR_CONFIGURATION_ADD_BIT_ZERO_SPACE, iValue);
    11de:	b7 01       	movw	r22, r14
    11e0:	8c e0       	ldi	r24, 0x0C	; 12
    11e2:	90 e0       	ldi	r25, 0x00	; 0
    11e4:	0e 94 c8 0d 	call	0x1b90	; 0x1b90 <__eeupd_word_m328>
            g_ir_formal.time_zero_bit_space= iValue;
    11e8:	f0 92 10 02 	sts	0x0210, r15
    11ec:	e0 92 0f 02 	sts	0x020F, r14
        }

        if(*(ptr+22) == IR_CONFIGURATION_LENGTH)
    11f0:	f8 01       	movw	r30, r16
    11f2:	86 89       	ldd	r24, Z+22	; 0x16
    11f4:	87 3f       	cpi	r24, 0xF7	; 247
    11f6:	91 f5       	brne	.+100    	; 0x125c <Zigbee_receive_data+0x230>
        {
            iValue = 0;
            iValue = (unsigned int) *(ptr+23);
    11f8:	e7 88       	ldd	r14, Z+23	; 0x17
    11fa:	f1 2c       	mov	r15, r1
            iValue = iValue <<8;
    11fc:	fe 2c       	mov	r15, r14
    11fe:	ee 24       	eor	r14, r14
            iValue = iValue  +  (unsigned int) *(ptr+24);
    1200:	80 8d       	ldd	r24, Z+24	; 0x18
    1202:	e8 0e       	add	r14, r24
    1204:	f1 1c       	adc	r15, r1
            eeprom_update_word(( uint16_t *) IR_CONFIGURATION_ADD_LENGTH, iValue);
    1206:	b7 01       	movw	r22, r14
    1208:	8e e0       	ldi	r24, 0x0E	; 14
    120a:	90 e0       	ldi	r25, 0x00	; 0
    120c:	0e 94 c8 0d 	call	0x1b90	; 0x1b90 <__eeupd_word_m328>
            g_ir_formal.data_length=  iValue;
    1210:	f0 92 12 02 	sts	0x0212, r15
    1214:	e0 92 11 02 	sts	0x0211, r14
    1218:	21 c0       	rjmp	.+66     	; 0x125c <Zigbee_receive_data+0x230>
        }


        /*End configuration*/
    } else if (*ptr == IR_TYPE_THE_LIGHTING)
    121a:	82 3f       	cpi	r24, 0xF2	; 242
    121c:	f9 f4       	brne	.+62     	; 0x125c <Zigbee_receive_data+0x230>
    {
        char *ptr_hexs = (char *)malloc( (length-1)*2+1);
    121e:	c7 01       	movw	r24, r14
    1220:	88 0f       	add	r24, r24
    1222:	99 1f       	adc	r25, r25
    1224:	01 97       	sbiw	r24, 0x01	; 1
    1226:	0e 94 8d 0a 	call	0x151a	; 0x151a <malloc>
    122a:	6c 01       	movw	r12, r24
        if (ptr_hexs == '\0')
    122c:	00 97       	sbiw	r24, 0x00	; 0
    122e:	e1 f0       	breq	.+56     	; 0x1268 <Zigbee_receive_data+0x23c>
        {
            return;
        }
        string_to_hex((ptr+1), (length-1),ptr_hexs);
    1230:	b7 01       	movw	r22, r14
    1232:	61 50       	subi	r22, 0x01	; 1
    1234:	71 09       	sbc	r23, r1
    1236:	ac 01       	movw	r20, r24
    1238:	c8 01       	movw	r24, r16
    123a:	01 96       	adiw	r24, 0x01	; 1
    123c:	0e 94 0c 06 	call	0xc18	; 0xc18 <string_to_hex>
        Light_parse_command((unsigned char *) ptr_hexs,8);
    1240:	68 e0       	ldi	r22, 0x08	; 8
    1242:	70 e0       	ldi	r23, 0x00	; 0
    1244:	c6 01       	movw	r24, r12
    1246:	0e 94 10 04 	call	0x820	; 0x820 <Light_parse_command>
        USART_Transmits("OK",2);
    124a:	62 e0       	ldi	r22, 0x02	; 2
    124c:	70 e0       	ldi	r23, 0x00	; 0
    124e:	8d ef       	ldi	r24, 0xFD	; 253
    1250:	91 e0       	ldi	r25, 0x01	; 1
    1252:	0e 94 60 09 	call	0x12c0	; 0x12c0 <USART_Transmits>
        /*Release memory*/
        free(ptr_hexs);
    1256:	c6 01       	movw	r24, r12
    1258:	0e 94 25 0b 	call	0x164a	; 0x164a <free>

    }

    /*Release memory*/
    if (ptr)
    125c:	01 15       	cp	r16, r1
    125e:	11 05       	cpc	r17, r1
    1260:	19 f0       	breq	.+6      	; 0x1268 <Zigbee_receive_data+0x23c>
    {
        free(ptr);
    1262:	c8 01       	movw	r24, r16
    1264:	0e 94 25 0b 	call	0x164a	; 0x164a <free>
        ptr = 0;
    }

}//End function
    1268:	0f 90       	pop	r0
    126a:	0f 90       	pop	r0
    126c:	0f 90       	pop	r0
    126e:	df 91       	pop	r29
    1270:	cf 91       	pop	r28
    1272:	1f 91       	pop	r17
    1274:	0f 91       	pop	r16
    1276:	ff 90       	pop	r15
    1278:	ef 90       	pop	r14
    127a:	df 90       	pop	r13
    127c:	cf 90       	pop	r12
    127e:	08 95       	ret

00001280 <USART_Init>:
#include <string.h>

void USART_Init(unsigned int ubrr)
{
	/*Set baud rate */
	UBRR0H = (unsigned char)(ubrr>>8);
    1280:	90 93 c5 00 	sts	0x00C5, r25
	UBRR0L = (unsigned char)ubrr;
    1284:	80 93 c4 00 	sts	0x00C4, r24
	/*Enable receiver and transmitter */
	UCSR0B = (1<<RXEN0)|(1<<TXEN0);
    1288:	88 e1       	ldi	r24, 0x18	; 24
    128a:	80 93 c1 00 	sts	0x00C1, r24
	/* Set frame format: 8data, 2stop bit */
	//UCSR0C = (1<<USBS0)|(3<<UCSZ00);
   /* Set frame format: 8data, 1 stop bit */
	UCSR0C = (1<<UCSZ00) | (1 << UCSZ01);
    128e:	86 e0       	ldi	r24, 0x06	; 6
    1290:	80 93 c2 00 	sts	0x00C2, r24
    1294:	08 95       	ret

00001296 <USART_Transmit>:

int USART_Transmit( unsigned char data)
{
	/* Wait for empty transmit buffer*/
	unsigned int counter = 0;
	while( !( UCSR0A & (1<<UDRE0)) )
    1296:	21 e2       	ldi	r18, 0x21	; 33
    1298:	3e e4       	ldi	r19, 0x4E	; 78
    129a:	e0 ec       	ldi	r30, 0xC0	; 192
    129c:	f0 e0       	ldi	r31, 0x00	; 0
    129e:	05 c0       	rjmp	.+10     	; 0x12aa <USART_Transmit+0x14>
    12a0:	21 50       	subi	r18, 0x01	; 1
    12a2:	31 09       	sbc	r19, r1
	{
		 counter++;
		//Timeout
		if(counter> 20000)
    12a4:	21 15       	cp	r18, r1
    12a6:	31 05       	cpc	r19, r1
    12a8:	41 f0       	breq	.+16     	; 0x12ba <USART_Transmit+0x24>

int USART_Transmit( unsigned char data)
{
	/* Wait for empty transmit buffer*/
	unsigned int counter = 0;
	while( !( UCSR0A & (1<<UDRE0)) )
    12aa:	90 81       	ld	r25, Z
    12ac:	95 ff       	sbrs	r25, 5
    12ae:	f8 cf       	rjmp	.-16     	; 0x12a0 <USART_Transmit+0xa>
		{
			return -1;
		}
	}
	/* Put data into buffer, sends the data*/
	UDR0 = data;
    12b0:	80 93 c6 00 	sts	0x00C6, r24
	return 0;
    12b4:	80 e0       	ldi	r24, 0x00	; 0
    12b6:	90 e0       	ldi	r25, 0x00	; 0
    12b8:	08 95       	ret
	{
		 counter++;
		//Timeout
		if(counter> 20000)
		{
			return -1;
    12ba:	8f ef       	ldi	r24, 0xFF	; 255
    12bc:	9f ef       	ldi	r25, 0xFF	; 255
		}
	}
	/* Put data into buffer, sends the data*/
	UDR0 = data;
	return 0;
}
    12be:	08 95       	ret

000012c0 <USART_Transmits>:

int USART_Transmits( unsigned char *ptr,unsigned int length)
{
    12c0:	ef 92       	push	r14
    12c2:	ff 92       	push	r15
    12c4:	0f 93       	push	r16
    12c6:	1f 93       	push	r17
    12c8:	cf 93       	push	r28
    12ca:	df 93       	push	r29
    12cc:	7b 01       	movw	r14, r22
	for(unsigned int i = 0; i< length; i++ )
    12ce:	61 15       	cp	r22, r1
    12d0:	71 05       	cpc	r23, r1
    12d2:	91 f0       	breq	.+36     	; 0x12f8 <USART_Transmits+0x38>
    12d4:	08 2f       	mov	r16, r24
    12d6:	19 2f       	mov	r17, r25
    12d8:	c0 e0       	ldi	r28, 0x00	; 0
    12da:	d0 e0       	ldi	r29, 0x00	; 0
	{
	   if(  USART_Transmit(ptr[i]) != 0)
    12dc:	f8 01       	movw	r30, r16
    12de:	81 91       	ld	r24, Z+
    12e0:	8f 01       	movw	r16, r30
    12e2:	0e 94 4b 09 	call	0x1296	; 0x1296 <USART_Transmit>
    12e6:	00 97       	sbiw	r24, 0x00	; 0
    12e8:	11 f0       	breq	.+4      	; 0x12ee <USART_Transmits+0x2e>
	   {
		   return i;
    12ea:	ce 01       	movw	r24, r28
    12ec:	07 c0       	rjmp	.+14     	; 0x12fc <USART_Transmits+0x3c>
	return 0;
}

int USART_Transmits( unsigned char *ptr,unsigned int length)
{
	for(unsigned int i = 0; i< length; i++ )
    12ee:	21 96       	adiw	r28, 0x01	; 1
    12f0:	ce 15       	cp	r28, r14
    12f2:	df 05       	cpc	r29, r15
    12f4:	99 f7       	brne	.-26     	; 0x12dc <USART_Transmits+0x1c>
    12f6:	02 c0       	rjmp	.+4      	; 0x12fc <USART_Transmits+0x3c>
	   if(  USART_Transmit(ptr[i]) != 0)
	   {
		   return i;
	   }
	}
	return 0;
    12f8:	80 e0       	ldi	r24, 0x00	; 0
    12fa:	90 e0       	ldi	r25, 0x00	; 0
}
    12fc:	df 91       	pop	r29
    12fe:	cf 91       	pop	r28
    1300:	1f 91       	pop	r17
    1302:	0f 91       	pop	r16
    1304:	ff 90       	pop	r15
    1306:	ef 90       	pop	r14
    1308:	08 95       	ret

0000130a <USART_Receive>:

int USART_Receive(unsigned char *data)
{   
	/* Wait for data to be received*/
	unsigned int counter = 0;
	while( !(UCSR0A & (1<<RXC0)) )
    130a:	21 e2       	ldi	r18, 0x21	; 33
    130c:	3e e4       	ldi	r19, 0x4E	; 78
    130e:	e0 ec       	ldi	r30, 0xC0	; 192
    1310:	f0 e0       	ldi	r31, 0x00	; 0
    1312:	05 c0       	rjmp	.+10     	; 0x131e <USART_Receive+0x14>
    1314:	21 50       	subi	r18, 0x01	; 1
    1316:	31 09       	sbc	r19, r1
	{
		//Timeout
		 counter++;
		 //Timeout
		 if(counter> 20000)
    1318:	21 15       	cp	r18, r1
    131a:	31 05       	cpc	r19, r1
    131c:	51 f0       	breq	.+20     	; 0x1332 <USART_Receive+0x28>

int USART_Receive(unsigned char *data)
{   
	/* Wait for data to be received*/
	unsigned int counter = 0;
	while( !(UCSR0A & (1<<RXC0)) )
    131e:	40 81       	ld	r20, Z
    1320:	44 23       	and	r20, r20
    1322:	c4 f7       	brge	.-16     	; 0x1314 <USART_Receive+0xa>
		 {
			 return -1;
		 }
	}
	/* Get and return received data from buffer*/
	*data = UDR0;
    1324:	20 91 c6 00 	lds	r18, 0x00C6
    1328:	fc 01       	movw	r30, r24
    132a:	20 83       	st	Z, r18
	return 0;
    132c:	80 e0       	ldi	r24, 0x00	; 0
    132e:	90 e0       	ldi	r25, 0x00	; 0
    1330:	08 95       	ret
		//Timeout
		 counter++;
		 //Timeout
		 if(counter> 20000)
		 {
			 return -1;
    1332:	8f ef       	ldi	r24, 0xFF	; 255
    1334:	9f ef       	ldi	r25, 0xFF	; 255
		 }
	}
	/* Get and return received data from buffer*/
	*data = UDR0;
	return 0;
}
    1336:	08 95       	ret

00001338 <USART_Receives>:

unsigned char* USART_Receives(unsigned int length, unsigned int *byte_read)
{
    1338:	af 92       	push	r10
    133a:	bf 92       	push	r11
    133c:	cf 92       	push	r12
    133e:	df 92       	push	r13
    1340:	ef 92       	push	r14
    1342:	ff 92       	push	r15
    1344:	0f 93       	push	r16
    1346:	1f 93       	push	r17
    1348:	cf 93       	push	r28
    134a:	df 93       	push	r29
    134c:	1f 92       	push	r1
    134e:	cd b7       	in	r28, 0x3d	; 61
    1350:	de b7       	in	r29, 0x3e	; 62
    1352:	6c 01       	movw	r12, r24
    1354:	7b 01       	movw	r14, r22
	 *byte_read = 0;
    1356:	fb 01       	movw	r30, r22
    1358:	11 82       	std	Z+1, r1	; 0x01
    135a:	10 82       	st	Z, r1
	unsigned char *ptr  = (unsigned char *)malloc( sizeof(unsigned char) *length + 1);
    135c:	01 96       	adiw	r24, 0x01	; 1
    135e:	0e 94 8d 0a 	call	0x151a	; 0x151a <malloc>
    1362:	5c 01       	movw	r10, r24
	if(ptr == '\0')
    1364:	00 97       	sbiw	r24, 0x00	; 0
    1366:	d9 f0       	breq	.+54     	; 0x139e <USART_Receives+0x66>
	{
		return ptr;
	}
	
	for(unsigned int i = 0; i< length ; i++)
    1368:	c1 14       	cp	r12, r1
    136a:	d1 04       	cpc	r13, r1
    136c:	c1 f0       	breq	.+48     	; 0x139e <USART_Receives+0x66>
    136e:	8c 01       	movw	r16, r24
    1370:	c8 0e       	add	r12, r24
    1372:	d9 1e       	adc	r13, r25
	{
		unsigned char data ;
		if(USART_Receive(&data) == 0)
    1374:	ce 01       	movw	r24, r28
    1376:	01 96       	adiw	r24, 0x01	; 1
    1378:	0e 94 85 09 	call	0x130a	; 0x130a <USART_Receive>
    137c:	89 2b       	or	r24, r25
    137e:	51 f4       	brne	.+20     	; 0x1394 <USART_Receives+0x5c>
		{
			ptr[i] =data;
    1380:	89 81       	ldd	r24, Y+1	; 0x01
    1382:	f8 01       	movw	r30, r16
    1384:	80 83       	st	Z, r24
			*byte_read =*byte_read+1;
    1386:	f7 01       	movw	r30, r14
    1388:	20 81       	ld	r18, Z
    138a:	31 81       	ldd	r19, Z+1	; 0x01
    138c:	2f 5f       	subi	r18, 0xFF	; 255
    138e:	3f 4f       	sbci	r19, 0xFF	; 255
    1390:	31 83       	std	Z+1, r19	; 0x01
    1392:	20 83       	st	Z, r18
    1394:	0f 5f       	subi	r16, 0xFF	; 255
    1396:	1f 4f       	sbci	r17, 0xFF	; 255
	if(ptr == '\0')
	{
		return ptr;
	}
	
	for(unsigned int i = 0; i< length ; i++)
    1398:	0c 15       	cp	r16, r12
    139a:	1d 05       	cpc	r17, r13
    139c:	59 f7       	brne	.-42     	; 0x1374 <USART_Receives+0x3c>
			*byte_read =*byte_read+1;
		}
	}
	
	return ptr;
}
    139e:	c5 01       	movw	r24, r10
    13a0:	0f 90       	pop	r0
    13a2:	df 91       	pop	r29
    13a4:	cf 91       	pop	r28
    13a6:	1f 91       	pop	r17
    13a8:	0f 91       	pop	r16
    13aa:	ff 90       	pop	r15
    13ac:	ef 90       	pop	r14
    13ae:	df 90       	pop	r13
    13b0:	cf 90       	pop	r12
    13b2:	bf 90       	pop	r11
    13b4:	af 90       	pop	r10
    13b6:	08 95       	ret

000013b8 <Timer1_init>:
{
	/*
	* Prescaler = 8
	* 8/(16000000) = 0.0000005 
	*/
	TCCR1B = (1<<CS11);
    13b8:	82 e0       	ldi	r24, 0x02	; 2
    13ba:	80 93 81 00 	sts	0x0081, r24
    TCNT1 = 0x0000 ; //Top = 0xFFFF->65535
    13be:	10 92 85 00 	sts	0x0085, r1
    13c2:	10 92 84 00 	sts	0x0084, r1
	TIMSK1 |= (1 << TOIE1);
    13c6:	ef e6       	ldi	r30, 0x6F	; 111
    13c8:	f0 e0       	ldi	r31, 0x00	; 0
    13ca:	80 81       	ld	r24, Z
    13cc:	81 60       	ori	r24, 0x01	; 1
    13ce:	80 83       	st	Z, r24
	sei();    
    13d0:	78 94       	sei
    13d2:	08 95       	ret

000013d4 <__vector_13>:
/*
*Interrupt service routine
* Timer1 overflow
*/
ISR(TIMER1_OVF_vect)
{
    13d4:	1f 92       	push	r1
    13d6:	0f 92       	push	r0
    13d8:	0f b6       	in	r0, 0x3f	; 63
    13da:	0f 92       	push	r0
    13dc:	11 24       	eor	r1, r1
    13de:	8f 93       	push	r24
	g_flag_timeout = -1;
    13e0:	8f ef       	ldi	r24, 0xFF	; 255
    13e2:	80 93 00 02 	sts	0x0200, r24
    13e6:	8f 91       	pop	r24
    13e8:	0f 90       	pop	r0
    13ea:	0f be       	out	0x3f, r0	; 63
    13ec:	0f 90       	pop	r0
    13ee:	1f 90       	pop	r1
    13f0:	18 95       	reti

000013f2 <setup>:
struct Zigbee_info gZigbeeInfo;


void setup()
{
	Light_init();
    13f2:	0e 94 ef 03 	call	0x7de	; 0x7de <Light_init>
	
	/*Atmega328 communication with ZIGBEE module*/
	USART_Init(MYUBRR);
    13f6:	89 e1       	ldi	r24, 0x19	; 25
    13f8:	90 e0       	ldi	r25, 0x00	; 0
    13fa:	0e 94 40 09 	call	0x1280	; 0x1280 <USART_Init>
	
	Zigbee_init();
    13fe:	0e 94 6d 07 	call	0xeda	; 0xeda <Zigbee_init>
	
	/*IR_init() has to call before IR starts */
	IR_init();
    1402:	0e 94 59 01 	call	0x2b2	; 0x2b2 <IR_init>
	
	/*Receiver IR*/
    Timer0_init();
    1406:	0e 94 bc 00 	call	0x178	; 0x178 <Timer0_init>
	INT0_init();
    140a:	0e 94 db 00 	call	0x1b6	; 0x1b6 <INT0_init>
	
	/*sleep()*/
	Timer1_init();
    140e:	0e 94 dc 09 	call	0x13b8	; 0x13b8 <Timer1_init>
	
	/*SenderIR*/ 
	Timer2_init();
    1412:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <Timer2_init>
	/*Timer2 will start before INIT1 */
    INT1_init();
    1416:	0e 94 23 01 	call	0x246	; 0x246 <INT1_init>
    141a:	08 95       	ret

0000141c <main>:
}

int main(void)
{ 
    setup();
    141c:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <setup>
    ZigBee_get_Config();
    1420:	0e 94 ff 07 	call	0xffe	; 0xffe <ZigBee_get_Config>
	
	 PinWrite(PIN_A0, LOW); 
    1424:	60 e0       	ldi	r22, 0x00	; 0
    1426:	80 e0       	ldi	r24, 0x00	; 0
    1428:	0e 94 45 0a 	call	0x148a	; 0x148a <PinWrite>
     if( verifyPanID() ==  0)
    142c:	0e 94 82 07 	call	0xf04	; 0xf04 <verifyPanID>
    1430:	89 2b       	or	r24, r25
    1432:	21 f4       	brne	.+8      	; 0x143c <main+0x20>
     {
	     PinWrite(PIN_A0, HIGHT);
    1434:	61 e0       	ldi	r22, 0x01	; 1
    1436:	80 e0       	ldi	r24, 0x00	; 0
    1438:	0e 94 45 0a 	call	0x148a	; 0x148a <PinWrite>
	unsigned char key_9[] = "E0E0708F";
	unsigned char key_0[] = "E0E08877";
	unsigned char key_led0[] ="A0A05F30";*/
	while(1)
	{ 
	    Zigbee_receive_data();
    143c:	0e 94 16 08 	call	0x102c	; 0x102c <Zigbee_receive_data>
    1440:	fd cf       	rjmp	.-6      	; 0x143c <main+0x20>

00001442 <PinMode>:
}


void PinMode(PIN pin, MODE mode)
{  
	if (pin == PIN_A0)
    1442:	81 11       	cpse	r24, r1
    1444:	07 c0       	rjmp	.+14     	; 0x1454 <PinMode+0x12>
	{
		if (mode == OUTPUT )
    1446:	61 30       	cpi	r22, 0x01	; 1
    1448:	19 f4       	brne	.+6      	; 0x1450 <PinMode+0xe>
			/*
			If PORTxn is written logic one when the pin is configured as an output pin, the port pin is driven
			high (one). If PORTxn is written logic zero when the pin is configured as an output pin, the port
			pin is driven low (zero).
			*/
			PORTC |= (1<<PORTC0);
    144a:	40 9a       	sbi	0x08, 0	; 8
			
			DDRC  |= (1<<DDC0);
    144c:	38 9a       	sbi	0x07, 0	; 7
    144e:	08 95       	ret

#define PIN_RXI PD0
#define PIN_TXO PD1*/
void setZerobit(unsigned char *DDRX, char PCX)
{   
	*DDRX &= ~(1<<PCX);
    1450:	38 98       	cbi	0x07, 0	; 7
    1452:	08 95       	ret
		}
		else//INPUT
		{   
			setZerobit((unsigned char *)&DDRC,PORTC0);
		}
	}else if (pin == PIN_A1)
    1454:	81 30       	cpi	r24, 0x01	; 1
    1456:	39 f4       	brne	.+14     	; 0x1466 <PinMode+0x24>
	{
		if (mode == OUTPUT )
    1458:	61 30       	cpi	r22, 0x01	; 1
    145a:	19 f4       	brne	.+6      	; 0x1462 <PinMode+0x20>
		{
			PORTC |= (1<<PORTC1);
    145c:	41 9a       	sbi	0x08, 1	; 8
			DDRC  |= (1<<DDC1);
    145e:	39 9a       	sbi	0x07, 1	; 7
    1460:	08 95       	ret

#define PIN_RXI PD0
#define PIN_TXO PD1*/
void setZerobit(unsigned char *DDRX, char PCX)
{   
	*DDRX &= ~(1<<PCX);
    1462:	39 98       	cbi	0x07, 1	; 7
    1464:	08 95       	ret
		}
		else//INPUT
		{   
			setZerobit((unsigned char *)&DDRC,PORTC1);
		}
	}else if (pin == PIN_A2)
    1466:	82 30       	cpi	r24, 0x02	; 2
    1468:	39 f4       	brne	.+14     	; 0x1478 <PinMode+0x36>
	{
		if (mode == OUTPUT )
    146a:	61 30       	cpi	r22, 0x01	; 1
    146c:	19 f4       	brne	.+6      	; 0x1474 <PinMode+0x32>
		{
			PORTC |= (1<<PORTC2);
    146e:	42 9a       	sbi	0x08, 2	; 8
			DDRC  |= (1<<DDC2);
    1470:	3a 9a       	sbi	0x07, 2	; 7
    1472:	08 95       	ret

#define PIN_RXI PD0
#define PIN_TXO PD1*/
void setZerobit(unsigned char *DDRX, char PCX)
{   
	*DDRX &= ~(1<<PCX);
    1474:	3a 98       	cbi	0x07, 2	; 7
    1476:	08 95       	ret
		}
		else//INPUT
		{
			setZerobit((unsigned char *)&DDRC,PORTC2);
		}
	}else if (pin == PIN_A3)
    1478:	83 30       	cpi	r24, 0x03	; 3
    147a:	31 f4       	brne	.+12     	; 0x1488 <PinMode+0x46>
	{
		
		if (mode == OUTPUT )
    147c:	61 30       	cpi	r22, 0x01	; 1
    147e:	19 f4       	brne	.+6      	; 0x1486 <PinMode+0x44>
		{
			PORTC |= (1<<PORTC3);
    1480:	43 9a       	sbi	0x08, 3	; 8
			DDRC  |= (1<<DDC3);
    1482:	3b 9a       	sbi	0x07, 3	; 7
    1484:	08 95       	ret

#define PIN_RXI PD0
#define PIN_TXO PD1*/
void setZerobit(unsigned char *DDRX, char PCX)
{   
	*DDRX &= ~(1<<PCX);
    1486:	3b 98       	cbi	0x07, 3	; 7
    1488:	08 95       	ret

0000148a <PinWrite>:
		}
	}
}
void PinWrite(PIN pin, VALUE value)
{
	if (pin == PIN_A0)
    148a:	81 11       	cpse	r24, r1
    148c:	06 c0       	rjmp	.+12     	; 0x149a <PinWrite+0x10>
	{
		if (value == HIGHT )
    148e:	61 30       	cpi	r22, 0x01	; 1
    1490:	11 f4       	brne	.+4      	; 0x1496 <PinWrite+0xc>
	*DDRX &= ~(1<<PCX);
}

void setOneBit(unsigned char *DDRX, char PCX)
{
	*DDRX |= (1<<PCX);
    1492:	40 9a       	sbi	0x08, 0	; 8
    1494:	08 95       	ret

#define PIN_RXI PD0
#define PIN_TXO PD1*/
void setZerobit(unsigned char *DDRX, char PCX)
{   
	*DDRX &= ~(1<<PCX);
    1496:	40 98       	cbi	0x08, 0	; 8
    1498:	08 95       	ret
		}
		else//LOW
		{
			setZerobit( (unsigned char *)&PORTC,PORTC0);
		}
	}else if (pin == PIN_A1)
    149a:	81 30       	cpi	r24, 0x01	; 1
    149c:	31 f4       	brne	.+12     	; 0x14aa <PinWrite+0x20>
	{
		if (value == HIGHT )
    149e:	61 30       	cpi	r22, 0x01	; 1
    14a0:	11 f4       	brne	.+4      	; 0x14a6 <PinWrite+0x1c>
	*DDRX &= ~(1<<PCX);
}

void setOneBit(unsigned char *DDRX, char PCX)
{
	*DDRX |= (1<<PCX);
    14a2:	41 9a       	sbi	0x08, 1	; 8
    14a4:	08 95       	ret

#define PIN_RXI PD0
#define PIN_TXO PD1*/
void setZerobit(unsigned char *DDRX, char PCX)
{   
	*DDRX &= ~(1<<PCX);
    14a6:	41 98       	cbi	0x08, 1	; 8
    14a8:	08 95       	ret
		}
		else//LOW
		{
			setZerobit( (unsigned char *)&PORTC,PORTC1);
		}
	}else if (pin == PIN_A2)
    14aa:	82 30       	cpi	r24, 0x02	; 2
    14ac:	31 f4       	brne	.+12     	; 0x14ba <PinWrite+0x30>
	{
		if (value == HIGHT )
    14ae:	61 30       	cpi	r22, 0x01	; 1
    14b0:	11 f4       	brne	.+4      	; 0x14b6 <PinWrite+0x2c>
	*DDRX &= ~(1<<PCX);
}

void setOneBit(unsigned char *DDRX, char PCX)
{
	*DDRX |= (1<<PCX);
    14b2:	42 9a       	sbi	0x08, 2	; 8
    14b4:	08 95       	ret

#define PIN_RXI PD0
#define PIN_TXO PD1*/
void setZerobit(unsigned char *DDRX, char PCX)
{   
	*DDRX &= ~(1<<PCX);
    14b6:	42 98       	cbi	0x08, 2	; 8
    14b8:	08 95       	ret
		}
		else//LOW
		{
			setZerobit( (unsigned char *)&PORTC,PORTC2);
		}
	}else if (pin == PIN_A3)
    14ba:	83 30       	cpi	r24, 0x03	; 3
    14bc:	29 f4       	brne	.+10     	; 0x14c8 <PinWrite+0x3e>
	{
		if (value == HIGHT )
    14be:	61 30       	cpi	r22, 0x01	; 1
    14c0:	11 f4       	brne	.+4      	; 0x14c6 <PinWrite+0x3c>
	*DDRX &= ~(1<<PCX);
}

void setOneBit(unsigned char *DDRX, char PCX)
{
	*DDRX |= (1<<PCX);
    14c2:	43 9a       	sbi	0x08, 3	; 8
    14c4:	08 95       	ret

#define PIN_RXI PD0
#define PIN_TXO PD1*/
void setZerobit(unsigned char *DDRX, char PCX)
{   
	*DDRX &= ~(1<<PCX);
    14c6:	43 98       	cbi	0x08, 3	; 8
    14c8:	08 95       	ret

000014ca <__udivmodsi4>:
    14ca:	a1 e2       	ldi	r26, 0x21	; 33
    14cc:	1a 2e       	mov	r1, r26
    14ce:	aa 1b       	sub	r26, r26
    14d0:	bb 1b       	sub	r27, r27
    14d2:	fd 01       	movw	r30, r26
    14d4:	0d c0       	rjmp	.+26     	; 0x14f0 <__udivmodsi4_ep>

000014d6 <__udivmodsi4_loop>:
    14d6:	aa 1f       	adc	r26, r26
    14d8:	bb 1f       	adc	r27, r27
    14da:	ee 1f       	adc	r30, r30
    14dc:	ff 1f       	adc	r31, r31
    14de:	a2 17       	cp	r26, r18
    14e0:	b3 07       	cpc	r27, r19
    14e2:	e4 07       	cpc	r30, r20
    14e4:	f5 07       	cpc	r31, r21
    14e6:	20 f0       	brcs	.+8      	; 0x14f0 <__udivmodsi4_ep>
    14e8:	a2 1b       	sub	r26, r18
    14ea:	b3 0b       	sbc	r27, r19
    14ec:	e4 0b       	sbc	r30, r20
    14ee:	f5 0b       	sbc	r31, r21

000014f0 <__udivmodsi4_ep>:
    14f0:	66 1f       	adc	r22, r22
    14f2:	77 1f       	adc	r23, r23
    14f4:	88 1f       	adc	r24, r24
    14f6:	99 1f       	adc	r25, r25
    14f8:	1a 94       	dec	r1
    14fa:	69 f7       	brne	.-38     	; 0x14d6 <__udivmodsi4_loop>
    14fc:	60 95       	com	r22
    14fe:	70 95       	com	r23
    1500:	80 95       	com	r24
    1502:	90 95       	com	r25
    1504:	9b 01       	movw	r18, r22
    1506:	ac 01       	movw	r20, r24
    1508:	bd 01       	movw	r22, r26
    150a:	cf 01       	movw	r24, r30
    150c:	08 95       	ret

0000150e <__tablejump2__>:
    150e:	ee 0f       	add	r30, r30
    1510:	ff 1f       	adc	r31, r31

00001512 <__tablejump__>:
    1512:	05 90       	lpm	r0, Z+
    1514:	f4 91       	lpm	r31, Z
    1516:	e0 2d       	mov	r30, r0
    1518:	09 94       	ijmp

0000151a <malloc>:
    151a:	cf 93       	push	r28
    151c:	df 93       	push	r29
    151e:	82 30       	cpi	r24, 0x02	; 2
    1520:	91 05       	cpc	r25, r1
    1522:	10 f4       	brcc	.+4      	; 0x1528 <malloc+0xe>
    1524:	82 e0       	ldi	r24, 0x02	; 2
    1526:	90 e0       	ldi	r25, 0x00	; 0
    1528:	e0 91 5b 02 	lds	r30, 0x025B
    152c:	f0 91 5c 02 	lds	r31, 0x025C
    1530:	20 e0       	ldi	r18, 0x00	; 0
    1532:	30 e0       	ldi	r19, 0x00	; 0
    1534:	a0 e0       	ldi	r26, 0x00	; 0
    1536:	b0 e0       	ldi	r27, 0x00	; 0
    1538:	30 97       	sbiw	r30, 0x00	; 0
    153a:	39 f1       	breq	.+78     	; 0x158a <malloc+0x70>
    153c:	40 81       	ld	r20, Z
    153e:	51 81       	ldd	r21, Z+1	; 0x01
    1540:	48 17       	cp	r20, r24
    1542:	59 07       	cpc	r21, r25
    1544:	b8 f0       	brcs	.+46     	; 0x1574 <malloc+0x5a>
    1546:	48 17       	cp	r20, r24
    1548:	59 07       	cpc	r21, r25
    154a:	71 f4       	brne	.+28     	; 0x1568 <malloc+0x4e>
    154c:	82 81       	ldd	r24, Z+2	; 0x02
    154e:	93 81       	ldd	r25, Z+3	; 0x03
    1550:	10 97       	sbiw	r26, 0x00	; 0
    1552:	29 f0       	breq	.+10     	; 0x155e <malloc+0x44>
    1554:	13 96       	adiw	r26, 0x03	; 3
    1556:	9c 93       	st	X, r25
    1558:	8e 93       	st	-X, r24
    155a:	12 97       	sbiw	r26, 0x02	; 2
    155c:	2c c0       	rjmp	.+88     	; 0x15b6 <malloc+0x9c>
    155e:	90 93 5c 02 	sts	0x025C, r25
    1562:	80 93 5b 02 	sts	0x025B, r24
    1566:	27 c0       	rjmp	.+78     	; 0x15b6 <malloc+0x9c>
    1568:	21 15       	cp	r18, r1
    156a:	31 05       	cpc	r19, r1
    156c:	31 f0       	breq	.+12     	; 0x157a <malloc+0x60>
    156e:	42 17       	cp	r20, r18
    1570:	53 07       	cpc	r21, r19
    1572:	18 f0       	brcs	.+6      	; 0x157a <malloc+0x60>
    1574:	a9 01       	movw	r20, r18
    1576:	db 01       	movw	r26, r22
    1578:	01 c0       	rjmp	.+2      	; 0x157c <malloc+0x62>
    157a:	ef 01       	movw	r28, r30
    157c:	9a 01       	movw	r18, r20
    157e:	bd 01       	movw	r22, r26
    1580:	df 01       	movw	r26, r30
    1582:	02 80       	ldd	r0, Z+2	; 0x02
    1584:	f3 81       	ldd	r31, Z+3	; 0x03
    1586:	e0 2d       	mov	r30, r0
    1588:	d7 cf       	rjmp	.-82     	; 0x1538 <malloc+0x1e>
    158a:	21 15       	cp	r18, r1
    158c:	31 05       	cpc	r19, r1
    158e:	f9 f0       	breq	.+62     	; 0x15ce <malloc+0xb4>
    1590:	28 1b       	sub	r18, r24
    1592:	39 0b       	sbc	r19, r25
    1594:	24 30       	cpi	r18, 0x04	; 4
    1596:	31 05       	cpc	r19, r1
    1598:	80 f4       	brcc	.+32     	; 0x15ba <malloc+0xa0>
    159a:	8a 81       	ldd	r24, Y+2	; 0x02
    159c:	9b 81       	ldd	r25, Y+3	; 0x03
    159e:	61 15       	cp	r22, r1
    15a0:	71 05       	cpc	r23, r1
    15a2:	21 f0       	breq	.+8      	; 0x15ac <malloc+0x92>
    15a4:	fb 01       	movw	r30, r22
    15a6:	93 83       	std	Z+3, r25	; 0x03
    15a8:	82 83       	std	Z+2, r24	; 0x02
    15aa:	04 c0       	rjmp	.+8      	; 0x15b4 <malloc+0x9a>
    15ac:	90 93 5c 02 	sts	0x025C, r25
    15b0:	80 93 5b 02 	sts	0x025B, r24
    15b4:	fe 01       	movw	r30, r28
    15b6:	32 96       	adiw	r30, 0x02	; 2
    15b8:	44 c0       	rjmp	.+136    	; 0x1642 <malloc+0x128>
    15ba:	fe 01       	movw	r30, r28
    15bc:	e2 0f       	add	r30, r18
    15be:	f3 1f       	adc	r31, r19
    15c0:	81 93       	st	Z+, r24
    15c2:	91 93       	st	Z+, r25
    15c4:	22 50       	subi	r18, 0x02	; 2
    15c6:	31 09       	sbc	r19, r1
    15c8:	39 83       	std	Y+1, r19	; 0x01
    15ca:	28 83       	st	Y, r18
    15cc:	3a c0       	rjmp	.+116    	; 0x1642 <malloc+0x128>
    15ce:	20 91 59 02 	lds	r18, 0x0259
    15d2:	30 91 5a 02 	lds	r19, 0x025A
    15d6:	23 2b       	or	r18, r19
    15d8:	41 f4       	brne	.+16     	; 0x15ea <malloc+0xd0>
    15da:	20 91 02 01 	lds	r18, 0x0102
    15de:	30 91 03 01 	lds	r19, 0x0103
    15e2:	30 93 5a 02 	sts	0x025A, r19
    15e6:	20 93 59 02 	sts	0x0259, r18
    15ea:	20 91 00 01 	lds	r18, 0x0100
    15ee:	30 91 01 01 	lds	r19, 0x0101
    15f2:	21 15       	cp	r18, r1
    15f4:	31 05       	cpc	r19, r1
    15f6:	41 f4       	brne	.+16     	; 0x1608 <malloc+0xee>
    15f8:	2d b7       	in	r18, 0x3d	; 61
    15fa:	3e b7       	in	r19, 0x3e	; 62
    15fc:	40 91 04 01 	lds	r20, 0x0104
    1600:	50 91 05 01 	lds	r21, 0x0105
    1604:	24 1b       	sub	r18, r20
    1606:	35 0b       	sbc	r19, r21
    1608:	e0 91 59 02 	lds	r30, 0x0259
    160c:	f0 91 5a 02 	lds	r31, 0x025A
    1610:	e2 17       	cp	r30, r18
    1612:	f3 07       	cpc	r31, r19
    1614:	a0 f4       	brcc	.+40     	; 0x163e <malloc+0x124>
    1616:	2e 1b       	sub	r18, r30
    1618:	3f 0b       	sbc	r19, r31
    161a:	28 17       	cp	r18, r24
    161c:	39 07       	cpc	r19, r25
    161e:	78 f0       	brcs	.+30     	; 0x163e <malloc+0x124>
    1620:	ac 01       	movw	r20, r24
    1622:	4e 5f       	subi	r20, 0xFE	; 254
    1624:	5f 4f       	sbci	r21, 0xFF	; 255
    1626:	24 17       	cp	r18, r20
    1628:	35 07       	cpc	r19, r21
    162a:	48 f0       	brcs	.+18     	; 0x163e <malloc+0x124>
    162c:	4e 0f       	add	r20, r30
    162e:	5f 1f       	adc	r21, r31
    1630:	50 93 5a 02 	sts	0x025A, r21
    1634:	40 93 59 02 	sts	0x0259, r20
    1638:	81 93       	st	Z+, r24
    163a:	91 93       	st	Z+, r25
    163c:	02 c0       	rjmp	.+4      	; 0x1642 <malloc+0x128>
    163e:	e0 e0       	ldi	r30, 0x00	; 0
    1640:	f0 e0       	ldi	r31, 0x00	; 0
    1642:	cf 01       	movw	r24, r30
    1644:	df 91       	pop	r29
    1646:	cf 91       	pop	r28
    1648:	08 95       	ret

0000164a <free>:
    164a:	cf 93       	push	r28
    164c:	df 93       	push	r29
    164e:	00 97       	sbiw	r24, 0x00	; 0
    1650:	09 f4       	brne	.+2      	; 0x1654 <free+0xa>
    1652:	87 c0       	rjmp	.+270    	; 0x1762 <free+0x118>
    1654:	fc 01       	movw	r30, r24
    1656:	32 97       	sbiw	r30, 0x02	; 2
    1658:	13 82       	std	Z+3, r1	; 0x03
    165a:	12 82       	std	Z+2, r1	; 0x02
    165c:	c0 91 5b 02 	lds	r28, 0x025B
    1660:	d0 91 5c 02 	lds	r29, 0x025C
    1664:	20 97       	sbiw	r28, 0x00	; 0
    1666:	81 f4       	brne	.+32     	; 0x1688 <free+0x3e>
    1668:	20 81       	ld	r18, Z
    166a:	31 81       	ldd	r19, Z+1	; 0x01
    166c:	28 0f       	add	r18, r24
    166e:	39 1f       	adc	r19, r25
    1670:	80 91 59 02 	lds	r24, 0x0259
    1674:	90 91 5a 02 	lds	r25, 0x025A
    1678:	82 17       	cp	r24, r18
    167a:	93 07       	cpc	r25, r19
    167c:	79 f5       	brne	.+94     	; 0x16dc <free+0x92>
    167e:	f0 93 5a 02 	sts	0x025A, r31
    1682:	e0 93 59 02 	sts	0x0259, r30
    1686:	6d c0       	rjmp	.+218    	; 0x1762 <free+0x118>
    1688:	de 01       	movw	r26, r28
    168a:	20 e0       	ldi	r18, 0x00	; 0
    168c:	30 e0       	ldi	r19, 0x00	; 0
    168e:	ae 17       	cp	r26, r30
    1690:	bf 07       	cpc	r27, r31
    1692:	50 f4       	brcc	.+20     	; 0x16a8 <free+0x5e>
    1694:	12 96       	adiw	r26, 0x02	; 2
    1696:	4d 91       	ld	r20, X+
    1698:	5c 91       	ld	r21, X
    169a:	13 97       	sbiw	r26, 0x03	; 3
    169c:	9d 01       	movw	r18, r26
    169e:	41 15       	cp	r20, r1
    16a0:	51 05       	cpc	r21, r1
    16a2:	09 f1       	breq	.+66     	; 0x16e6 <free+0x9c>
    16a4:	da 01       	movw	r26, r20
    16a6:	f3 cf       	rjmp	.-26     	; 0x168e <free+0x44>
    16a8:	b3 83       	std	Z+3, r27	; 0x03
    16aa:	a2 83       	std	Z+2, r26	; 0x02
    16ac:	40 81       	ld	r20, Z
    16ae:	51 81       	ldd	r21, Z+1	; 0x01
    16b0:	84 0f       	add	r24, r20
    16b2:	95 1f       	adc	r25, r21
    16b4:	8a 17       	cp	r24, r26
    16b6:	9b 07       	cpc	r25, r27
    16b8:	71 f4       	brne	.+28     	; 0x16d6 <free+0x8c>
    16ba:	8d 91       	ld	r24, X+
    16bc:	9c 91       	ld	r25, X
    16be:	11 97       	sbiw	r26, 0x01	; 1
    16c0:	84 0f       	add	r24, r20
    16c2:	95 1f       	adc	r25, r21
    16c4:	02 96       	adiw	r24, 0x02	; 2
    16c6:	91 83       	std	Z+1, r25	; 0x01
    16c8:	80 83       	st	Z, r24
    16ca:	12 96       	adiw	r26, 0x02	; 2
    16cc:	8d 91       	ld	r24, X+
    16ce:	9c 91       	ld	r25, X
    16d0:	13 97       	sbiw	r26, 0x03	; 3
    16d2:	93 83       	std	Z+3, r25	; 0x03
    16d4:	82 83       	std	Z+2, r24	; 0x02
    16d6:	21 15       	cp	r18, r1
    16d8:	31 05       	cpc	r19, r1
    16da:	29 f4       	brne	.+10     	; 0x16e6 <free+0x9c>
    16dc:	f0 93 5c 02 	sts	0x025C, r31
    16e0:	e0 93 5b 02 	sts	0x025B, r30
    16e4:	3e c0       	rjmp	.+124    	; 0x1762 <free+0x118>
    16e6:	d9 01       	movw	r26, r18
    16e8:	13 96       	adiw	r26, 0x03	; 3
    16ea:	fc 93       	st	X, r31
    16ec:	ee 93       	st	-X, r30
    16ee:	12 97       	sbiw	r26, 0x02	; 2
    16f0:	4d 91       	ld	r20, X+
    16f2:	5d 91       	ld	r21, X+
    16f4:	a4 0f       	add	r26, r20
    16f6:	b5 1f       	adc	r27, r21
    16f8:	ea 17       	cp	r30, r26
    16fa:	fb 07       	cpc	r31, r27
    16fc:	79 f4       	brne	.+30     	; 0x171c <free+0xd2>
    16fe:	80 81       	ld	r24, Z
    1700:	91 81       	ldd	r25, Z+1	; 0x01
    1702:	84 0f       	add	r24, r20
    1704:	95 1f       	adc	r25, r21
    1706:	02 96       	adiw	r24, 0x02	; 2
    1708:	d9 01       	movw	r26, r18
    170a:	11 96       	adiw	r26, 0x01	; 1
    170c:	9c 93       	st	X, r25
    170e:	8e 93       	st	-X, r24
    1710:	82 81       	ldd	r24, Z+2	; 0x02
    1712:	93 81       	ldd	r25, Z+3	; 0x03
    1714:	13 96       	adiw	r26, 0x03	; 3
    1716:	9c 93       	st	X, r25
    1718:	8e 93       	st	-X, r24
    171a:	12 97       	sbiw	r26, 0x02	; 2
    171c:	e0 e0       	ldi	r30, 0x00	; 0
    171e:	f0 e0       	ldi	r31, 0x00	; 0
    1720:	8a 81       	ldd	r24, Y+2	; 0x02
    1722:	9b 81       	ldd	r25, Y+3	; 0x03
    1724:	00 97       	sbiw	r24, 0x00	; 0
    1726:	19 f0       	breq	.+6      	; 0x172e <free+0xe4>
    1728:	fe 01       	movw	r30, r28
    172a:	ec 01       	movw	r28, r24
    172c:	f9 cf       	rjmp	.-14     	; 0x1720 <free+0xd6>
    172e:	ce 01       	movw	r24, r28
    1730:	02 96       	adiw	r24, 0x02	; 2
    1732:	28 81       	ld	r18, Y
    1734:	39 81       	ldd	r19, Y+1	; 0x01
    1736:	82 0f       	add	r24, r18
    1738:	93 1f       	adc	r25, r19
    173a:	20 91 59 02 	lds	r18, 0x0259
    173e:	30 91 5a 02 	lds	r19, 0x025A
    1742:	28 17       	cp	r18, r24
    1744:	39 07       	cpc	r19, r25
    1746:	69 f4       	brne	.+26     	; 0x1762 <free+0x118>
    1748:	30 97       	sbiw	r30, 0x00	; 0
    174a:	29 f4       	brne	.+10     	; 0x1756 <free+0x10c>
    174c:	10 92 5c 02 	sts	0x025C, r1
    1750:	10 92 5b 02 	sts	0x025B, r1
    1754:	02 c0       	rjmp	.+4      	; 0x175a <free+0x110>
    1756:	13 82       	std	Z+3, r1	; 0x03
    1758:	12 82       	std	Z+2, r1	; 0x02
    175a:	d0 93 5a 02 	sts	0x025A, r29
    175e:	c0 93 59 02 	sts	0x0259, r28
    1762:	df 91       	pop	r29
    1764:	cf 91       	pop	r28
    1766:	08 95       	ret

00001768 <sprintf>:
    1768:	ae e0       	ldi	r26, 0x0E	; 14
    176a:	b0 e0       	ldi	r27, 0x00	; 0
    176c:	ea eb       	ldi	r30, 0xBA	; 186
    176e:	fb e0       	ldi	r31, 0x0B	; 11
    1770:	0c 94 92 0e 	jmp	0x1d24	; 0x1d24 <__prologue_saves__+0x1c>
    1774:	0d 89       	ldd	r16, Y+21	; 0x15
    1776:	1e 89       	ldd	r17, Y+22	; 0x16
    1778:	86 e0       	ldi	r24, 0x06	; 6
    177a:	8c 83       	std	Y+4, r24	; 0x04
    177c:	1a 83       	std	Y+2, r17	; 0x02
    177e:	09 83       	std	Y+1, r16	; 0x01
    1780:	8f ef       	ldi	r24, 0xFF	; 255
    1782:	9f e7       	ldi	r25, 0x7F	; 127
    1784:	9e 83       	std	Y+6, r25	; 0x06
    1786:	8d 83       	std	Y+5, r24	; 0x05
    1788:	ae 01       	movw	r20, r28
    178a:	47 5e       	subi	r20, 0xE7	; 231
    178c:	5f 4f       	sbci	r21, 0xFF	; 255
    178e:	6f 89       	ldd	r22, Y+23	; 0x17
    1790:	78 8d       	ldd	r23, Y+24	; 0x18
    1792:	ce 01       	movw	r24, r28
    1794:	01 96       	adiw	r24, 0x01	; 1
    1796:	0e 94 d6 0b 	call	0x17ac	; 0x17ac <vfprintf>
    179a:	ef 81       	ldd	r30, Y+7	; 0x07
    179c:	f8 85       	ldd	r31, Y+8	; 0x08
    179e:	e0 0f       	add	r30, r16
    17a0:	f1 1f       	adc	r31, r17
    17a2:	10 82       	st	Z, r1
    17a4:	2e 96       	adiw	r28, 0x0e	; 14
    17a6:	e4 e0       	ldi	r30, 0x04	; 4
    17a8:	0c 94 ae 0e 	jmp	0x1d5c	; 0x1d5c <__epilogue_restores__+0x1c>

000017ac <vfprintf>:
    17ac:	ac e0       	ldi	r26, 0x0C	; 12
    17ae:	b0 e0       	ldi	r27, 0x00	; 0
    17b0:	ec ed       	ldi	r30, 0xDC	; 220
    17b2:	fb e0       	ldi	r31, 0x0B	; 11
    17b4:	0c 94 84 0e 	jmp	0x1d08	; 0x1d08 <__prologue_saves__>
    17b8:	7c 01       	movw	r14, r24
    17ba:	6b 01       	movw	r12, r22
    17bc:	8a 01       	movw	r16, r20
    17be:	fc 01       	movw	r30, r24
    17c0:	17 82       	std	Z+7, r1	; 0x07
    17c2:	16 82       	std	Z+6, r1	; 0x06
    17c4:	83 81       	ldd	r24, Z+3	; 0x03
    17c6:	81 ff       	sbrs	r24, 1
    17c8:	bd c1       	rjmp	.+890    	; 0x1b44 <vfprintf+0x398>
    17ca:	ce 01       	movw	r24, r28
    17cc:	01 96       	adiw	r24, 0x01	; 1
    17ce:	4c 01       	movw	r8, r24
    17d0:	f7 01       	movw	r30, r14
    17d2:	93 81       	ldd	r25, Z+3	; 0x03
    17d4:	f6 01       	movw	r30, r12
    17d6:	93 fd       	sbrc	r25, 3
    17d8:	85 91       	lpm	r24, Z+
    17da:	93 ff       	sbrs	r25, 3
    17dc:	81 91       	ld	r24, Z+
    17de:	6f 01       	movw	r12, r30
    17e0:	88 23       	and	r24, r24
    17e2:	09 f4       	brne	.+2      	; 0x17e6 <vfprintf+0x3a>
    17e4:	ab c1       	rjmp	.+854    	; 0x1b3c <vfprintf+0x390>
    17e6:	85 32       	cpi	r24, 0x25	; 37
    17e8:	39 f4       	brne	.+14     	; 0x17f8 <vfprintf+0x4c>
    17ea:	93 fd       	sbrc	r25, 3
    17ec:	85 91       	lpm	r24, Z+
    17ee:	93 ff       	sbrs	r25, 3
    17f0:	81 91       	ld	r24, Z+
    17f2:	6f 01       	movw	r12, r30
    17f4:	85 32       	cpi	r24, 0x25	; 37
    17f6:	29 f4       	brne	.+10     	; 0x1802 <vfprintf+0x56>
    17f8:	b7 01       	movw	r22, r14
    17fa:	90 e0       	ldi	r25, 0x00	; 0
    17fc:	0e 94 e4 0d 	call	0x1bc8	; 0x1bc8 <fputc>
    1800:	e7 cf       	rjmp	.-50     	; 0x17d0 <vfprintf+0x24>
    1802:	51 2c       	mov	r5, r1
    1804:	31 2c       	mov	r3, r1
    1806:	20 e0       	ldi	r18, 0x00	; 0
    1808:	20 32       	cpi	r18, 0x20	; 32
    180a:	a0 f4       	brcc	.+40     	; 0x1834 <vfprintf+0x88>
    180c:	8b 32       	cpi	r24, 0x2B	; 43
    180e:	69 f0       	breq	.+26     	; 0x182a <vfprintf+0x7e>
    1810:	30 f4       	brcc	.+12     	; 0x181e <vfprintf+0x72>
    1812:	80 32       	cpi	r24, 0x20	; 32
    1814:	59 f0       	breq	.+22     	; 0x182c <vfprintf+0x80>
    1816:	83 32       	cpi	r24, 0x23	; 35
    1818:	69 f4       	brne	.+26     	; 0x1834 <vfprintf+0x88>
    181a:	20 61       	ori	r18, 0x10	; 16
    181c:	2c c0       	rjmp	.+88     	; 0x1876 <vfprintf+0xca>
    181e:	8d 32       	cpi	r24, 0x2D	; 45
    1820:	39 f0       	breq	.+14     	; 0x1830 <vfprintf+0x84>
    1822:	80 33       	cpi	r24, 0x30	; 48
    1824:	39 f4       	brne	.+14     	; 0x1834 <vfprintf+0x88>
    1826:	21 60       	ori	r18, 0x01	; 1
    1828:	26 c0       	rjmp	.+76     	; 0x1876 <vfprintf+0xca>
    182a:	22 60       	ori	r18, 0x02	; 2
    182c:	24 60       	ori	r18, 0x04	; 4
    182e:	23 c0       	rjmp	.+70     	; 0x1876 <vfprintf+0xca>
    1830:	28 60       	ori	r18, 0x08	; 8
    1832:	21 c0       	rjmp	.+66     	; 0x1876 <vfprintf+0xca>
    1834:	27 fd       	sbrc	r18, 7
    1836:	27 c0       	rjmp	.+78     	; 0x1886 <vfprintf+0xda>
    1838:	30 ed       	ldi	r19, 0xD0	; 208
    183a:	38 0f       	add	r19, r24
    183c:	3a 30       	cpi	r19, 0x0A	; 10
    183e:	78 f4       	brcc	.+30     	; 0x185e <vfprintf+0xb2>
    1840:	26 ff       	sbrs	r18, 6
    1842:	06 c0       	rjmp	.+12     	; 0x1850 <vfprintf+0xa4>
    1844:	fa e0       	ldi	r31, 0x0A	; 10
    1846:	5f 9e       	mul	r5, r31
    1848:	30 0d       	add	r19, r0
    184a:	11 24       	eor	r1, r1
    184c:	53 2e       	mov	r5, r19
    184e:	13 c0       	rjmp	.+38     	; 0x1876 <vfprintf+0xca>
    1850:	8a e0       	ldi	r24, 0x0A	; 10
    1852:	38 9e       	mul	r3, r24
    1854:	30 0d       	add	r19, r0
    1856:	11 24       	eor	r1, r1
    1858:	33 2e       	mov	r3, r19
    185a:	20 62       	ori	r18, 0x20	; 32
    185c:	0c c0       	rjmp	.+24     	; 0x1876 <vfprintf+0xca>
    185e:	8e 32       	cpi	r24, 0x2E	; 46
    1860:	21 f4       	brne	.+8      	; 0x186a <vfprintf+0xbe>
    1862:	26 fd       	sbrc	r18, 6
    1864:	6b c1       	rjmp	.+726    	; 0x1b3c <vfprintf+0x390>
    1866:	20 64       	ori	r18, 0x40	; 64
    1868:	06 c0       	rjmp	.+12     	; 0x1876 <vfprintf+0xca>
    186a:	8c 36       	cpi	r24, 0x6C	; 108
    186c:	11 f4       	brne	.+4      	; 0x1872 <vfprintf+0xc6>
    186e:	20 68       	ori	r18, 0x80	; 128
    1870:	02 c0       	rjmp	.+4      	; 0x1876 <vfprintf+0xca>
    1872:	88 36       	cpi	r24, 0x68	; 104
    1874:	41 f4       	brne	.+16     	; 0x1886 <vfprintf+0xda>
    1876:	f6 01       	movw	r30, r12
    1878:	93 fd       	sbrc	r25, 3
    187a:	85 91       	lpm	r24, Z+
    187c:	93 ff       	sbrs	r25, 3
    187e:	81 91       	ld	r24, Z+
    1880:	6f 01       	movw	r12, r30
    1882:	81 11       	cpse	r24, r1
    1884:	c1 cf       	rjmp	.-126    	; 0x1808 <vfprintf+0x5c>
    1886:	98 2f       	mov	r25, r24
    1888:	9f 7d       	andi	r25, 0xDF	; 223
    188a:	95 54       	subi	r25, 0x45	; 69
    188c:	93 30       	cpi	r25, 0x03	; 3
    188e:	28 f4       	brcc	.+10     	; 0x189a <vfprintf+0xee>
    1890:	0c 5f       	subi	r16, 0xFC	; 252
    1892:	1f 4f       	sbci	r17, 0xFF	; 255
    1894:	ff e3       	ldi	r31, 0x3F	; 63
    1896:	f9 83       	std	Y+1, r31	; 0x01
    1898:	0d c0       	rjmp	.+26     	; 0x18b4 <vfprintf+0x108>
    189a:	83 36       	cpi	r24, 0x63	; 99
    189c:	31 f0       	breq	.+12     	; 0x18aa <vfprintf+0xfe>
    189e:	83 37       	cpi	r24, 0x73	; 115
    18a0:	71 f0       	breq	.+28     	; 0x18be <vfprintf+0x112>
    18a2:	83 35       	cpi	r24, 0x53	; 83
    18a4:	09 f0       	breq	.+2      	; 0x18a8 <vfprintf+0xfc>
    18a6:	5b c0       	rjmp	.+182    	; 0x195e <vfprintf+0x1b2>
    18a8:	22 c0       	rjmp	.+68     	; 0x18ee <vfprintf+0x142>
    18aa:	f8 01       	movw	r30, r16
    18ac:	80 81       	ld	r24, Z
    18ae:	89 83       	std	Y+1, r24	; 0x01
    18b0:	0e 5f       	subi	r16, 0xFE	; 254
    18b2:	1f 4f       	sbci	r17, 0xFF	; 255
    18b4:	44 24       	eor	r4, r4
    18b6:	43 94       	inc	r4
    18b8:	51 2c       	mov	r5, r1
    18ba:	54 01       	movw	r10, r8
    18bc:	15 c0       	rjmp	.+42     	; 0x18e8 <vfprintf+0x13c>
    18be:	38 01       	movw	r6, r16
    18c0:	f2 e0       	ldi	r31, 0x02	; 2
    18c2:	6f 0e       	add	r6, r31
    18c4:	71 1c       	adc	r7, r1
    18c6:	f8 01       	movw	r30, r16
    18c8:	a0 80       	ld	r10, Z
    18ca:	b1 80       	ldd	r11, Z+1	; 0x01
    18cc:	26 ff       	sbrs	r18, 6
    18ce:	03 c0       	rjmp	.+6      	; 0x18d6 <vfprintf+0x12a>
    18d0:	65 2d       	mov	r22, r5
    18d2:	70 e0       	ldi	r23, 0x00	; 0
    18d4:	02 c0       	rjmp	.+4      	; 0x18da <vfprintf+0x12e>
    18d6:	6f ef       	ldi	r22, 0xFF	; 255
    18d8:	7f ef       	ldi	r23, 0xFF	; 255
    18da:	c5 01       	movw	r24, r10
    18dc:	2c 87       	std	Y+12, r18	; 0x0c
    18de:	0e 94 d9 0d 	call	0x1bb2	; 0x1bb2 <strnlen>
    18e2:	2c 01       	movw	r4, r24
    18e4:	83 01       	movw	r16, r6
    18e6:	2c 85       	ldd	r18, Y+12	; 0x0c
    18e8:	2f 77       	andi	r18, 0x7F	; 127
    18ea:	22 2e       	mov	r2, r18
    18ec:	17 c0       	rjmp	.+46     	; 0x191c <vfprintf+0x170>
    18ee:	38 01       	movw	r6, r16
    18f0:	f2 e0       	ldi	r31, 0x02	; 2
    18f2:	6f 0e       	add	r6, r31
    18f4:	71 1c       	adc	r7, r1
    18f6:	f8 01       	movw	r30, r16
    18f8:	a0 80       	ld	r10, Z
    18fa:	b1 80       	ldd	r11, Z+1	; 0x01
    18fc:	26 ff       	sbrs	r18, 6
    18fe:	03 c0       	rjmp	.+6      	; 0x1906 <vfprintf+0x15a>
    1900:	65 2d       	mov	r22, r5
    1902:	70 e0       	ldi	r23, 0x00	; 0
    1904:	02 c0       	rjmp	.+4      	; 0x190a <vfprintf+0x15e>
    1906:	6f ef       	ldi	r22, 0xFF	; 255
    1908:	7f ef       	ldi	r23, 0xFF	; 255
    190a:	c5 01       	movw	r24, r10
    190c:	2c 87       	std	Y+12, r18	; 0x0c
    190e:	0e 94 ce 0d 	call	0x1b9c	; 0x1b9c <strnlen_P>
    1912:	2c 01       	movw	r4, r24
    1914:	2c 85       	ldd	r18, Y+12	; 0x0c
    1916:	20 68       	ori	r18, 0x80	; 128
    1918:	22 2e       	mov	r2, r18
    191a:	83 01       	movw	r16, r6
    191c:	23 fc       	sbrc	r2, 3
    191e:	1b c0       	rjmp	.+54     	; 0x1956 <vfprintf+0x1aa>
    1920:	83 2d       	mov	r24, r3
    1922:	90 e0       	ldi	r25, 0x00	; 0
    1924:	48 16       	cp	r4, r24
    1926:	59 06       	cpc	r5, r25
    1928:	b0 f4       	brcc	.+44     	; 0x1956 <vfprintf+0x1aa>
    192a:	b7 01       	movw	r22, r14
    192c:	80 e2       	ldi	r24, 0x20	; 32
    192e:	90 e0       	ldi	r25, 0x00	; 0
    1930:	0e 94 e4 0d 	call	0x1bc8	; 0x1bc8 <fputc>
    1934:	3a 94       	dec	r3
    1936:	f4 cf       	rjmp	.-24     	; 0x1920 <vfprintf+0x174>
    1938:	f5 01       	movw	r30, r10
    193a:	27 fc       	sbrc	r2, 7
    193c:	85 91       	lpm	r24, Z+
    193e:	27 fe       	sbrs	r2, 7
    1940:	81 91       	ld	r24, Z+
    1942:	5f 01       	movw	r10, r30
    1944:	b7 01       	movw	r22, r14
    1946:	90 e0       	ldi	r25, 0x00	; 0
    1948:	0e 94 e4 0d 	call	0x1bc8	; 0x1bc8 <fputc>
    194c:	31 10       	cpse	r3, r1
    194e:	3a 94       	dec	r3
    1950:	f1 e0       	ldi	r31, 0x01	; 1
    1952:	4f 1a       	sub	r4, r31
    1954:	51 08       	sbc	r5, r1
    1956:	41 14       	cp	r4, r1
    1958:	51 04       	cpc	r5, r1
    195a:	71 f7       	brne	.-36     	; 0x1938 <vfprintf+0x18c>
    195c:	e5 c0       	rjmp	.+458    	; 0x1b28 <vfprintf+0x37c>
    195e:	84 36       	cpi	r24, 0x64	; 100
    1960:	11 f0       	breq	.+4      	; 0x1966 <vfprintf+0x1ba>
    1962:	89 36       	cpi	r24, 0x69	; 105
    1964:	39 f5       	brne	.+78     	; 0x19b4 <vfprintf+0x208>
    1966:	f8 01       	movw	r30, r16
    1968:	27 ff       	sbrs	r18, 7
    196a:	07 c0       	rjmp	.+14     	; 0x197a <vfprintf+0x1ce>
    196c:	60 81       	ld	r22, Z
    196e:	71 81       	ldd	r23, Z+1	; 0x01
    1970:	82 81       	ldd	r24, Z+2	; 0x02
    1972:	93 81       	ldd	r25, Z+3	; 0x03
    1974:	0c 5f       	subi	r16, 0xFC	; 252
    1976:	1f 4f       	sbci	r17, 0xFF	; 255
    1978:	08 c0       	rjmp	.+16     	; 0x198a <vfprintf+0x1de>
    197a:	60 81       	ld	r22, Z
    197c:	71 81       	ldd	r23, Z+1	; 0x01
    197e:	88 27       	eor	r24, r24
    1980:	77 fd       	sbrc	r23, 7
    1982:	80 95       	com	r24
    1984:	98 2f       	mov	r25, r24
    1986:	0e 5f       	subi	r16, 0xFE	; 254
    1988:	1f 4f       	sbci	r17, 0xFF	; 255
    198a:	2f 76       	andi	r18, 0x6F	; 111
    198c:	b2 2e       	mov	r11, r18
    198e:	97 ff       	sbrs	r25, 7
    1990:	09 c0       	rjmp	.+18     	; 0x19a4 <vfprintf+0x1f8>
    1992:	90 95       	com	r25
    1994:	80 95       	com	r24
    1996:	70 95       	com	r23
    1998:	61 95       	neg	r22
    199a:	7f 4f       	sbci	r23, 0xFF	; 255
    199c:	8f 4f       	sbci	r24, 0xFF	; 255
    199e:	9f 4f       	sbci	r25, 0xFF	; 255
    19a0:	20 68       	ori	r18, 0x80	; 128
    19a2:	b2 2e       	mov	r11, r18
    19a4:	2a e0       	ldi	r18, 0x0A	; 10
    19a6:	30 e0       	ldi	r19, 0x00	; 0
    19a8:	a4 01       	movw	r20, r8
    19aa:	0e 94 16 0e 	call	0x1c2c	; 0x1c2c <__ultoa_invert>
    19ae:	a8 2e       	mov	r10, r24
    19b0:	a8 18       	sub	r10, r8
    19b2:	44 c0       	rjmp	.+136    	; 0x1a3c <vfprintf+0x290>
    19b4:	85 37       	cpi	r24, 0x75	; 117
    19b6:	29 f4       	brne	.+10     	; 0x19c2 <vfprintf+0x216>
    19b8:	2f 7e       	andi	r18, 0xEF	; 239
    19ba:	b2 2e       	mov	r11, r18
    19bc:	2a e0       	ldi	r18, 0x0A	; 10
    19be:	30 e0       	ldi	r19, 0x00	; 0
    19c0:	25 c0       	rjmp	.+74     	; 0x1a0c <vfprintf+0x260>
    19c2:	f2 2f       	mov	r31, r18
    19c4:	f9 7f       	andi	r31, 0xF9	; 249
    19c6:	bf 2e       	mov	r11, r31
    19c8:	8f 36       	cpi	r24, 0x6F	; 111
    19ca:	c1 f0       	breq	.+48     	; 0x19fc <vfprintf+0x250>
    19cc:	18 f4       	brcc	.+6      	; 0x19d4 <vfprintf+0x228>
    19ce:	88 35       	cpi	r24, 0x58	; 88
    19d0:	79 f0       	breq	.+30     	; 0x19f0 <vfprintf+0x244>
    19d2:	b4 c0       	rjmp	.+360    	; 0x1b3c <vfprintf+0x390>
    19d4:	80 37       	cpi	r24, 0x70	; 112
    19d6:	19 f0       	breq	.+6      	; 0x19de <vfprintf+0x232>
    19d8:	88 37       	cpi	r24, 0x78	; 120
    19da:	21 f0       	breq	.+8      	; 0x19e4 <vfprintf+0x238>
    19dc:	af c0       	rjmp	.+350    	; 0x1b3c <vfprintf+0x390>
    19de:	2f 2f       	mov	r18, r31
    19e0:	20 61       	ori	r18, 0x10	; 16
    19e2:	b2 2e       	mov	r11, r18
    19e4:	b4 fe       	sbrs	r11, 4
    19e6:	0d c0       	rjmp	.+26     	; 0x1a02 <vfprintf+0x256>
    19e8:	8b 2d       	mov	r24, r11
    19ea:	84 60       	ori	r24, 0x04	; 4
    19ec:	b8 2e       	mov	r11, r24
    19ee:	09 c0       	rjmp	.+18     	; 0x1a02 <vfprintf+0x256>
    19f0:	24 ff       	sbrs	r18, 4
    19f2:	0a c0       	rjmp	.+20     	; 0x1a08 <vfprintf+0x25c>
    19f4:	9f 2f       	mov	r25, r31
    19f6:	96 60       	ori	r25, 0x06	; 6
    19f8:	b9 2e       	mov	r11, r25
    19fa:	06 c0       	rjmp	.+12     	; 0x1a08 <vfprintf+0x25c>
    19fc:	28 e0       	ldi	r18, 0x08	; 8
    19fe:	30 e0       	ldi	r19, 0x00	; 0
    1a00:	05 c0       	rjmp	.+10     	; 0x1a0c <vfprintf+0x260>
    1a02:	20 e1       	ldi	r18, 0x10	; 16
    1a04:	30 e0       	ldi	r19, 0x00	; 0
    1a06:	02 c0       	rjmp	.+4      	; 0x1a0c <vfprintf+0x260>
    1a08:	20 e1       	ldi	r18, 0x10	; 16
    1a0a:	32 e0       	ldi	r19, 0x02	; 2
    1a0c:	f8 01       	movw	r30, r16
    1a0e:	b7 fe       	sbrs	r11, 7
    1a10:	07 c0       	rjmp	.+14     	; 0x1a20 <vfprintf+0x274>
    1a12:	60 81       	ld	r22, Z
    1a14:	71 81       	ldd	r23, Z+1	; 0x01
    1a16:	82 81       	ldd	r24, Z+2	; 0x02
    1a18:	93 81       	ldd	r25, Z+3	; 0x03
    1a1a:	0c 5f       	subi	r16, 0xFC	; 252
    1a1c:	1f 4f       	sbci	r17, 0xFF	; 255
    1a1e:	06 c0       	rjmp	.+12     	; 0x1a2c <vfprintf+0x280>
    1a20:	60 81       	ld	r22, Z
    1a22:	71 81       	ldd	r23, Z+1	; 0x01
    1a24:	80 e0       	ldi	r24, 0x00	; 0
    1a26:	90 e0       	ldi	r25, 0x00	; 0
    1a28:	0e 5f       	subi	r16, 0xFE	; 254
    1a2a:	1f 4f       	sbci	r17, 0xFF	; 255
    1a2c:	a4 01       	movw	r20, r8
    1a2e:	0e 94 16 0e 	call	0x1c2c	; 0x1c2c <__ultoa_invert>
    1a32:	a8 2e       	mov	r10, r24
    1a34:	a8 18       	sub	r10, r8
    1a36:	fb 2d       	mov	r31, r11
    1a38:	ff 77       	andi	r31, 0x7F	; 127
    1a3a:	bf 2e       	mov	r11, r31
    1a3c:	b6 fe       	sbrs	r11, 6
    1a3e:	0b c0       	rjmp	.+22     	; 0x1a56 <vfprintf+0x2aa>
    1a40:	2b 2d       	mov	r18, r11
    1a42:	2e 7f       	andi	r18, 0xFE	; 254
    1a44:	a5 14       	cp	r10, r5
    1a46:	50 f4       	brcc	.+20     	; 0x1a5c <vfprintf+0x2b0>
    1a48:	b4 fe       	sbrs	r11, 4
    1a4a:	0a c0       	rjmp	.+20     	; 0x1a60 <vfprintf+0x2b4>
    1a4c:	b2 fc       	sbrc	r11, 2
    1a4e:	08 c0       	rjmp	.+16     	; 0x1a60 <vfprintf+0x2b4>
    1a50:	2b 2d       	mov	r18, r11
    1a52:	2e 7e       	andi	r18, 0xEE	; 238
    1a54:	05 c0       	rjmp	.+10     	; 0x1a60 <vfprintf+0x2b4>
    1a56:	7a 2c       	mov	r7, r10
    1a58:	2b 2d       	mov	r18, r11
    1a5a:	03 c0       	rjmp	.+6      	; 0x1a62 <vfprintf+0x2b6>
    1a5c:	7a 2c       	mov	r7, r10
    1a5e:	01 c0       	rjmp	.+2      	; 0x1a62 <vfprintf+0x2b6>
    1a60:	75 2c       	mov	r7, r5
    1a62:	24 ff       	sbrs	r18, 4
    1a64:	0d c0       	rjmp	.+26     	; 0x1a80 <vfprintf+0x2d4>
    1a66:	fe 01       	movw	r30, r28
    1a68:	ea 0d       	add	r30, r10
    1a6a:	f1 1d       	adc	r31, r1
    1a6c:	80 81       	ld	r24, Z
    1a6e:	80 33       	cpi	r24, 0x30	; 48
    1a70:	11 f4       	brne	.+4      	; 0x1a76 <vfprintf+0x2ca>
    1a72:	29 7e       	andi	r18, 0xE9	; 233
    1a74:	09 c0       	rjmp	.+18     	; 0x1a88 <vfprintf+0x2dc>
    1a76:	22 ff       	sbrs	r18, 2
    1a78:	06 c0       	rjmp	.+12     	; 0x1a86 <vfprintf+0x2da>
    1a7a:	73 94       	inc	r7
    1a7c:	73 94       	inc	r7
    1a7e:	04 c0       	rjmp	.+8      	; 0x1a88 <vfprintf+0x2dc>
    1a80:	82 2f       	mov	r24, r18
    1a82:	86 78       	andi	r24, 0x86	; 134
    1a84:	09 f0       	breq	.+2      	; 0x1a88 <vfprintf+0x2dc>
    1a86:	73 94       	inc	r7
    1a88:	23 fd       	sbrc	r18, 3
    1a8a:	13 c0       	rjmp	.+38     	; 0x1ab2 <vfprintf+0x306>
    1a8c:	20 ff       	sbrs	r18, 0
    1a8e:	06 c0       	rjmp	.+12     	; 0x1a9c <vfprintf+0x2f0>
    1a90:	5a 2c       	mov	r5, r10
    1a92:	73 14       	cp	r7, r3
    1a94:	18 f4       	brcc	.+6      	; 0x1a9c <vfprintf+0x2f0>
    1a96:	53 0c       	add	r5, r3
    1a98:	57 18       	sub	r5, r7
    1a9a:	73 2c       	mov	r7, r3
    1a9c:	73 14       	cp	r7, r3
    1a9e:	68 f4       	brcc	.+26     	; 0x1aba <vfprintf+0x30e>
    1aa0:	b7 01       	movw	r22, r14
    1aa2:	80 e2       	ldi	r24, 0x20	; 32
    1aa4:	90 e0       	ldi	r25, 0x00	; 0
    1aa6:	2c 87       	std	Y+12, r18	; 0x0c
    1aa8:	0e 94 e4 0d 	call	0x1bc8	; 0x1bc8 <fputc>
    1aac:	73 94       	inc	r7
    1aae:	2c 85       	ldd	r18, Y+12	; 0x0c
    1ab0:	f5 cf       	rjmp	.-22     	; 0x1a9c <vfprintf+0x2f0>
    1ab2:	73 14       	cp	r7, r3
    1ab4:	10 f4       	brcc	.+4      	; 0x1aba <vfprintf+0x30e>
    1ab6:	37 18       	sub	r3, r7
    1ab8:	01 c0       	rjmp	.+2      	; 0x1abc <vfprintf+0x310>
    1aba:	31 2c       	mov	r3, r1
    1abc:	24 ff       	sbrs	r18, 4
    1abe:	12 c0       	rjmp	.+36     	; 0x1ae4 <vfprintf+0x338>
    1ac0:	b7 01       	movw	r22, r14
    1ac2:	80 e3       	ldi	r24, 0x30	; 48
    1ac4:	90 e0       	ldi	r25, 0x00	; 0
    1ac6:	2c 87       	std	Y+12, r18	; 0x0c
    1ac8:	0e 94 e4 0d 	call	0x1bc8	; 0x1bc8 <fputc>
    1acc:	2c 85       	ldd	r18, Y+12	; 0x0c
    1ace:	22 ff       	sbrs	r18, 2
    1ad0:	17 c0       	rjmp	.+46     	; 0x1b00 <vfprintf+0x354>
    1ad2:	21 ff       	sbrs	r18, 1
    1ad4:	03 c0       	rjmp	.+6      	; 0x1adc <vfprintf+0x330>
    1ad6:	88 e5       	ldi	r24, 0x58	; 88
    1ad8:	90 e0       	ldi	r25, 0x00	; 0
    1ada:	02 c0       	rjmp	.+4      	; 0x1ae0 <vfprintf+0x334>
    1adc:	88 e7       	ldi	r24, 0x78	; 120
    1ade:	90 e0       	ldi	r25, 0x00	; 0
    1ae0:	b7 01       	movw	r22, r14
    1ae2:	0c c0       	rjmp	.+24     	; 0x1afc <vfprintf+0x350>
    1ae4:	82 2f       	mov	r24, r18
    1ae6:	86 78       	andi	r24, 0x86	; 134
    1ae8:	59 f0       	breq	.+22     	; 0x1b00 <vfprintf+0x354>
    1aea:	21 fd       	sbrc	r18, 1
    1aec:	02 c0       	rjmp	.+4      	; 0x1af2 <vfprintf+0x346>
    1aee:	80 e2       	ldi	r24, 0x20	; 32
    1af0:	01 c0       	rjmp	.+2      	; 0x1af4 <vfprintf+0x348>
    1af2:	8b e2       	ldi	r24, 0x2B	; 43
    1af4:	27 fd       	sbrc	r18, 7
    1af6:	8d e2       	ldi	r24, 0x2D	; 45
    1af8:	b7 01       	movw	r22, r14
    1afa:	90 e0       	ldi	r25, 0x00	; 0
    1afc:	0e 94 e4 0d 	call	0x1bc8	; 0x1bc8 <fputc>
    1b00:	a5 14       	cp	r10, r5
    1b02:	38 f4       	brcc	.+14     	; 0x1b12 <vfprintf+0x366>
    1b04:	b7 01       	movw	r22, r14
    1b06:	80 e3       	ldi	r24, 0x30	; 48
    1b08:	90 e0       	ldi	r25, 0x00	; 0
    1b0a:	0e 94 e4 0d 	call	0x1bc8	; 0x1bc8 <fputc>
    1b0e:	5a 94       	dec	r5
    1b10:	f7 cf       	rjmp	.-18     	; 0x1b00 <vfprintf+0x354>
    1b12:	aa 94       	dec	r10
    1b14:	f4 01       	movw	r30, r8
    1b16:	ea 0d       	add	r30, r10
    1b18:	f1 1d       	adc	r31, r1
    1b1a:	80 81       	ld	r24, Z
    1b1c:	b7 01       	movw	r22, r14
    1b1e:	90 e0       	ldi	r25, 0x00	; 0
    1b20:	0e 94 e4 0d 	call	0x1bc8	; 0x1bc8 <fputc>
    1b24:	a1 10       	cpse	r10, r1
    1b26:	f5 cf       	rjmp	.-22     	; 0x1b12 <vfprintf+0x366>
    1b28:	33 20       	and	r3, r3
    1b2a:	09 f4       	brne	.+2      	; 0x1b2e <vfprintf+0x382>
    1b2c:	51 ce       	rjmp	.-862    	; 0x17d0 <vfprintf+0x24>
    1b2e:	b7 01       	movw	r22, r14
    1b30:	80 e2       	ldi	r24, 0x20	; 32
    1b32:	90 e0       	ldi	r25, 0x00	; 0
    1b34:	0e 94 e4 0d 	call	0x1bc8	; 0x1bc8 <fputc>
    1b38:	3a 94       	dec	r3
    1b3a:	f6 cf       	rjmp	.-20     	; 0x1b28 <vfprintf+0x37c>
    1b3c:	f7 01       	movw	r30, r14
    1b3e:	86 81       	ldd	r24, Z+6	; 0x06
    1b40:	97 81       	ldd	r25, Z+7	; 0x07
    1b42:	02 c0       	rjmp	.+4      	; 0x1b48 <vfprintf+0x39c>
    1b44:	8f ef       	ldi	r24, 0xFF	; 255
    1b46:	9f ef       	ldi	r25, 0xFF	; 255
    1b48:	2c 96       	adiw	r28, 0x0c	; 12
    1b4a:	e2 e1       	ldi	r30, 0x12	; 18
    1b4c:	0c 94 a0 0e 	jmp	0x1d40	; 0x1d40 <__epilogue_restores__>

00001b50 <__eerd_byte_m328>:
    1b50:	f9 99       	sbic	0x1f, 1	; 31
    1b52:	fe cf       	rjmp	.-4      	; 0x1b50 <__eerd_byte_m328>
    1b54:	92 bd       	out	0x22, r25	; 34
    1b56:	81 bd       	out	0x21, r24	; 33
    1b58:	f8 9a       	sbi	0x1f, 0	; 31
    1b5a:	99 27       	eor	r25, r25
    1b5c:	80 b5       	in	r24, 0x20	; 32
    1b5e:	08 95       	ret

00001b60 <__eerd_word_m328>:
    1b60:	a8 e1       	ldi	r26, 0x18	; 24
    1b62:	b0 e0       	ldi	r27, 0x00	; 0
    1b64:	42 e0       	ldi	r20, 0x02	; 2
    1b66:	50 e0       	ldi	r21, 0x00	; 0
    1b68:	0c 94 76 0e 	jmp	0x1cec	; 0x1cec <__eerd_blraw_m328>

00001b6c <__eeupd_byte_m328>:
    1b6c:	26 2f       	mov	r18, r22

00001b6e <__eeupd_r18_m328>:
    1b6e:	f9 99       	sbic	0x1f, 1	; 31
    1b70:	fe cf       	rjmp	.-4      	; 0x1b6e <__eeupd_r18_m328>
    1b72:	92 bd       	out	0x22, r25	; 34
    1b74:	81 bd       	out	0x21, r24	; 33
    1b76:	f8 9a       	sbi	0x1f, 0	; 31
    1b78:	01 97       	sbiw	r24, 0x01	; 1
    1b7a:	00 b4       	in	r0, 0x20	; 32
    1b7c:	02 16       	cp	r0, r18
    1b7e:	39 f0       	breq	.+14     	; 0x1b8e <__eeupd_r18_m328+0x20>
    1b80:	1f ba       	out	0x1f, r1	; 31
    1b82:	20 bd       	out	0x20, r18	; 32
    1b84:	0f b6       	in	r0, 0x3f	; 63
    1b86:	f8 94       	cli
    1b88:	fa 9a       	sbi	0x1f, 2	; 31
    1b8a:	f9 9a       	sbi	0x1f, 1	; 31
    1b8c:	0f be       	out	0x3f, r0	; 63
    1b8e:	08 95       	ret

00001b90 <__eeupd_word_m328>:
    1b90:	01 96       	adiw	r24, 0x01	; 1
    1b92:	27 2f       	mov	r18, r23
    1b94:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <__eeupd_r18_m328>
    1b98:	0c 94 b6 0d 	jmp	0x1b6c	; 0x1b6c <__eeupd_byte_m328>

00001b9c <strnlen_P>:
    1b9c:	fc 01       	movw	r30, r24
    1b9e:	05 90       	lpm	r0, Z+
    1ba0:	61 50       	subi	r22, 0x01	; 1
    1ba2:	70 40       	sbci	r23, 0x00	; 0
    1ba4:	01 10       	cpse	r0, r1
    1ba6:	d8 f7       	brcc	.-10     	; 0x1b9e <strnlen_P+0x2>
    1ba8:	80 95       	com	r24
    1baa:	90 95       	com	r25
    1bac:	8e 0f       	add	r24, r30
    1bae:	9f 1f       	adc	r25, r31
    1bb0:	08 95       	ret

00001bb2 <strnlen>:
    1bb2:	fc 01       	movw	r30, r24
    1bb4:	61 50       	subi	r22, 0x01	; 1
    1bb6:	70 40       	sbci	r23, 0x00	; 0
    1bb8:	01 90       	ld	r0, Z+
    1bba:	01 10       	cpse	r0, r1
    1bbc:	d8 f7       	brcc	.-10     	; 0x1bb4 <strnlen+0x2>
    1bbe:	80 95       	com	r24
    1bc0:	90 95       	com	r25
    1bc2:	8e 0f       	add	r24, r30
    1bc4:	9f 1f       	adc	r25, r31
    1bc6:	08 95       	ret

00001bc8 <fputc>:
    1bc8:	0f 93       	push	r16
    1bca:	1f 93       	push	r17
    1bcc:	cf 93       	push	r28
    1bce:	df 93       	push	r29
    1bd0:	18 2f       	mov	r17, r24
    1bd2:	09 2f       	mov	r16, r25
    1bd4:	eb 01       	movw	r28, r22
    1bd6:	8b 81       	ldd	r24, Y+3	; 0x03
    1bd8:	81 fd       	sbrc	r24, 1
    1bda:	03 c0       	rjmp	.+6      	; 0x1be2 <fputc+0x1a>
    1bdc:	8f ef       	ldi	r24, 0xFF	; 255
    1bde:	9f ef       	ldi	r25, 0xFF	; 255
    1be0:	20 c0       	rjmp	.+64     	; 0x1c22 <fputc+0x5a>
    1be2:	82 ff       	sbrs	r24, 2
    1be4:	10 c0       	rjmp	.+32     	; 0x1c06 <fputc+0x3e>
    1be6:	4e 81       	ldd	r20, Y+6	; 0x06
    1be8:	5f 81       	ldd	r21, Y+7	; 0x07
    1bea:	2c 81       	ldd	r18, Y+4	; 0x04
    1bec:	3d 81       	ldd	r19, Y+5	; 0x05
    1bee:	42 17       	cp	r20, r18
    1bf0:	53 07       	cpc	r21, r19
    1bf2:	7c f4       	brge	.+30     	; 0x1c12 <fputc+0x4a>
    1bf4:	e8 81       	ld	r30, Y
    1bf6:	f9 81       	ldd	r31, Y+1	; 0x01
    1bf8:	9f 01       	movw	r18, r30
    1bfa:	2f 5f       	subi	r18, 0xFF	; 255
    1bfc:	3f 4f       	sbci	r19, 0xFF	; 255
    1bfe:	39 83       	std	Y+1, r19	; 0x01
    1c00:	28 83       	st	Y, r18
    1c02:	10 83       	st	Z, r17
    1c04:	06 c0       	rjmp	.+12     	; 0x1c12 <fputc+0x4a>
    1c06:	e8 85       	ldd	r30, Y+8	; 0x08
    1c08:	f9 85       	ldd	r31, Y+9	; 0x09
    1c0a:	81 2f       	mov	r24, r17
    1c0c:	09 95       	icall
    1c0e:	89 2b       	or	r24, r25
    1c10:	29 f7       	brne	.-54     	; 0x1bdc <fputc+0x14>
    1c12:	2e 81       	ldd	r18, Y+6	; 0x06
    1c14:	3f 81       	ldd	r19, Y+7	; 0x07
    1c16:	2f 5f       	subi	r18, 0xFF	; 255
    1c18:	3f 4f       	sbci	r19, 0xFF	; 255
    1c1a:	3f 83       	std	Y+7, r19	; 0x07
    1c1c:	2e 83       	std	Y+6, r18	; 0x06
    1c1e:	81 2f       	mov	r24, r17
    1c20:	90 2f       	mov	r25, r16
    1c22:	df 91       	pop	r29
    1c24:	cf 91       	pop	r28
    1c26:	1f 91       	pop	r17
    1c28:	0f 91       	pop	r16
    1c2a:	08 95       	ret

00001c2c <__ultoa_invert>:
    1c2c:	fa 01       	movw	r30, r20
    1c2e:	aa 27       	eor	r26, r26
    1c30:	28 30       	cpi	r18, 0x08	; 8
    1c32:	51 f1       	breq	.+84     	; 0x1c88 <__ultoa_invert+0x5c>
    1c34:	20 31       	cpi	r18, 0x10	; 16
    1c36:	81 f1       	breq	.+96     	; 0x1c98 <__ultoa_invert+0x6c>
    1c38:	e8 94       	clt
    1c3a:	6f 93       	push	r22
    1c3c:	6e 7f       	andi	r22, 0xFE	; 254
    1c3e:	6e 5f       	subi	r22, 0xFE	; 254
    1c40:	7f 4f       	sbci	r23, 0xFF	; 255
    1c42:	8f 4f       	sbci	r24, 0xFF	; 255
    1c44:	9f 4f       	sbci	r25, 0xFF	; 255
    1c46:	af 4f       	sbci	r26, 0xFF	; 255
    1c48:	b1 e0       	ldi	r27, 0x01	; 1
    1c4a:	3e d0       	rcall	.+124    	; 0x1cc8 <__ultoa_invert+0x9c>
    1c4c:	b4 e0       	ldi	r27, 0x04	; 4
    1c4e:	3c d0       	rcall	.+120    	; 0x1cc8 <__ultoa_invert+0x9c>
    1c50:	67 0f       	add	r22, r23
    1c52:	78 1f       	adc	r23, r24
    1c54:	89 1f       	adc	r24, r25
    1c56:	9a 1f       	adc	r25, r26
    1c58:	a1 1d       	adc	r26, r1
    1c5a:	68 0f       	add	r22, r24
    1c5c:	79 1f       	adc	r23, r25
    1c5e:	8a 1f       	adc	r24, r26
    1c60:	91 1d       	adc	r25, r1
    1c62:	a1 1d       	adc	r26, r1
    1c64:	6a 0f       	add	r22, r26
    1c66:	71 1d       	adc	r23, r1
    1c68:	81 1d       	adc	r24, r1
    1c6a:	91 1d       	adc	r25, r1
    1c6c:	a1 1d       	adc	r26, r1
    1c6e:	20 d0       	rcall	.+64     	; 0x1cb0 <__ultoa_invert+0x84>
    1c70:	09 f4       	brne	.+2      	; 0x1c74 <__ultoa_invert+0x48>
    1c72:	68 94       	set
    1c74:	3f 91       	pop	r19
    1c76:	2a e0       	ldi	r18, 0x0A	; 10
    1c78:	26 9f       	mul	r18, r22
    1c7a:	11 24       	eor	r1, r1
    1c7c:	30 19       	sub	r19, r0
    1c7e:	30 5d       	subi	r19, 0xD0	; 208
    1c80:	31 93       	st	Z+, r19
    1c82:	de f6       	brtc	.-74     	; 0x1c3a <__ultoa_invert+0xe>
    1c84:	cf 01       	movw	r24, r30
    1c86:	08 95       	ret
    1c88:	46 2f       	mov	r20, r22
    1c8a:	47 70       	andi	r20, 0x07	; 7
    1c8c:	40 5d       	subi	r20, 0xD0	; 208
    1c8e:	41 93       	st	Z+, r20
    1c90:	b3 e0       	ldi	r27, 0x03	; 3
    1c92:	0f d0       	rcall	.+30     	; 0x1cb2 <__ultoa_invert+0x86>
    1c94:	c9 f7       	brne	.-14     	; 0x1c88 <__ultoa_invert+0x5c>
    1c96:	f6 cf       	rjmp	.-20     	; 0x1c84 <__ultoa_invert+0x58>
    1c98:	46 2f       	mov	r20, r22
    1c9a:	4f 70       	andi	r20, 0x0F	; 15
    1c9c:	40 5d       	subi	r20, 0xD0	; 208
    1c9e:	4a 33       	cpi	r20, 0x3A	; 58
    1ca0:	18 f0       	brcs	.+6      	; 0x1ca8 <__ultoa_invert+0x7c>
    1ca2:	49 5d       	subi	r20, 0xD9	; 217
    1ca4:	31 fd       	sbrc	r19, 1
    1ca6:	40 52       	subi	r20, 0x20	; 32
    1ca8:	41 93       	st	Z+, r20
    1caa:	02 d0       	rcall	.+4      	; 0x1cb0 <__ultoa_invert+0x84>
    1cac:	a9 f7       	brne	.-22     	; 0x1c98 <__ultoa_invert+0x6c>
    1cae:	ea cf       	rjmp	.-44     	; 0x1c84 <__ultoa_invert+0x58>
    1cb0:	b4 e0       	ldi	r27, 0x04	; 4
    1cb2:	a6 95       	lsr	r26
    1cb4:	97 95       	ror	r25
    1cb6:	87 95       	ror	r24
    1cb8:	77 95       	ror	r23
    1cba:	67 95       	ror	r22
    1cbc:	ba 95       	dec	r27
    1cbe:	c9 f7       	brne	.-14     	; 0x1cb2 <__ultoa_invert+0x86>
    1cc0:	00 97       	sbiw	r24, 0x00	; 0
    1cc2:	61 05       	cpc	r22, r1
    1cc4:	71 05       	cpc	r23, r1
    1cc6:	08 95       	ret
    1cc8:	9b 01       	movw	r18, r22
    1cca:	ac 01       	movw	r20, r24
    1ccc:	0a 2e       	mov	r0, r26
    1cce:	06 94       	lsr	r0
    1cd0:	57 95       	ror	r21
    1cd2:	47 95       	ror	r20
    1cd4:	37 95       	ror	r19
    1cd6:	27 95       	ror	r18
    1cd8:	ba 95       	dec	r27
    1cda:	c9 f7       	brne	.-14     	; 0x1cce <__ultoa_invert+0xa2>
    1cdc:	62 0f       	add	r22, r18
    1cde:	73 1f       	adc	r23, r19
    1ce0:	84 1f       	adc	r24, r20
    1ce2:	95 1f       	adc	r25, r21
    1ce4:	a0 1d       	adc	r26, r0
    1ce6:	08 95       	ret

00001ce8 <__eerd_block_m328>:
    1ce8:	dc 01       	movw	r26, r24
    1cea:	cb 01       	movw	r24, r22

00001cec <__eerd_blraw_m328>:
    1cec:	fc 01       	movw	r30, r24
    1cee:	f9 99       	sbic	0x1f, 1	; 31
    1cf0:	fe cf       	rjmp	.-4      	; 0x1cee <__eerd_blraw_m328+0x2>
    1cf2:	06 c0       	rjmp	.+12     	; 0x1d00 <__eerd_blraw_m328+0x14>
    1cf4:	f2 bd       	out	0x22, r31	; 34
    1cf6:	e1 bd       	out	0x21, r30	; 33
    1cf8:	f8 9a       	sbi	0x1f, 0	; 31
    1cfa:	31 96       	adiw	r30, 0x01	; 1
    1cfc:	00 b4       	in	r0, 0x20	; 32
    1cfe:	0d 92       	st	X+, r0
    1d00:	41 50       	subi	r20, 0x01	; 1
    1d02:	50 40       	sbci	r21, 0x00	; 0
    1d04:	b8 f7       	brcc	.-18     	; 0x1cf4 <__eerd_blraw_m328+0x8>
    1d06:	08 95       	ret

00001d08 <__prologue_saves__>:
    1d08:	2f 92       	push	r2
    1d0a:	3f 92       	push	r3
    1d0c:	4f 92       	push	r4
    1d0e:	5f 92       	push	r5
    1d10:	6f 92       	push	r6
    1d12:	7f 92       	push	r7
    1d14:	8f 92       	push	r8
    1d16:	9f 92       	push	r9
    1d18:	af 92       	push	r10
    1d1a:	bf 92       	push	r11
    1d1c:	cf 92       	push	r12
    1d1e:	df 92       	push	r13
    1d20:	ef 92       	push	r14
    1d22:	ff 92       	push	r15
    1d24:	0f 93       	push	r16
    1d26:	1f 93       	push	r17
    1d28:	cf 93       	push	r28
    1d2a:	df 93       	push	r29
    1d2c:	cd b7       	in	r28, 0x3d	; 61
    1d2e:	de b7       	in	r29, 0x3e	; 62
    1d30:	ca 1b       	sub	r28, r26
    1d32:	db 0b       	sbc	r29, r27
    1d34:	0f b6       	in	r0, 0x3f	; 63
    1d36:	f8 94       	cli
    1d38:	de bf       	out	0x3e, r29	; 62
    1d3a:	0f be       	out	0x3f, r0	; 63
    1d3c:	cd bf       	out	0x3d, r28	; 61
    1d3e:	09 94       	ijmp

00001d40 <__epilogue_restores__>:
    1d40:	2a 88       	ldd	r2, Y+18	; 0x12
    1d42:	39 88       	ldd	r3, Y+17	; 0x11
    1d44:	48 88       	ldd	r4, Y+16	; 0x10
    1d46:	5f 84       	ldd	r5, Y+15	; 0x0f
    1d48:	6e 84       	ldd	r6, Y+14	; 0x0e
    1d4a:	7d 84       	ldd	r7, Y+13	; 0x0d
    1d4c:	8c 84       	ldd	r8, Y+12	; 0x0c
    1d4e:	9b 84       	ldd	r9, Y+11	; 0x0b
    1d50:	aa 84       	ldd	r10, Y+10	; 0x0a
    1d52:	b9 84       	ldd	r11, Y+9	; 0x09
    1d54:	c8 84       	ldd	r12, Y+8	; 0x08
    1d56:	df 80       	ldd	r13, Y+7	; 0x07
    1d58:	ee 80       	ldd	r14, Y+6	; 0x06
    1d5a:	fd 80       	ldd	r15, Y+5	; 0x05
    1d5c:	0c 81       	ldd	r16, Y+4	; 0x04
    1d5e:	1b 81       	ldd	r17, Y+3	; 0x03
    1d60:	aa 81       	ldd	r26, Y+2	; 0x02
    1d62:	b9 81       	ldd	r27, Y+1	; 0x01
    1d64:	ce 0f       	add	r28, r30
    1d66:	d1 1d       	adc	r29, r1
    1d68:	0f b6       	in	r0, 0x3f	; 63
    1d6a:	f8 94       	cli
    1d6c:	de bf       	out	0x3e, r29	; 62
    1d6e:	0f be       	out	0x3f, r0	; 63
    1d70:	cd bf       	out	0x3d, r28	; 61
    1d72:	ed 01       	movw	r28, r26
    1d74:	08 95       	ret

00001d76 <_exit>:
    1d76:	f8 94       	cli

00001d78 <__stop_program>:
    1d78:	ff cf       	rjmp	.-2      	; 0x1d78 <__stop_program>
